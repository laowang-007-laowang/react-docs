<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>React-Hooks完整参考 - React 中文文档</title>
  <meta name="description" content="从入门到精通，全面掌握React开发技能">
  <link rel="stylesheet" href="assets/style.css">
  <link rel="stylesheet" href="assets/highlight.css">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>⚛️</text></svg>">
</head>
<body>
  <div class="container">
    <!-- 顶部导航 -->
    <header class="header">
      <div class="header-content">
        <div class="logo">
          <span class="logo-icon">⚛️</span>
          <div class="logo-text">
            <h1>React 中文文档</h1>
            <p>现代化的React学习指南</p>
          </div>
        </div>
        <nav class="header-nav">
          <a href="index.html" class="nav-link">首页</a>
          <a href="#" class="nav-link" onclick="toggleSidebar()">目录</a>
          <a href="https://github.com/facebook/react" target="_blank" class="nav-link">GitHub</a>
        </nav>
      </div>
    </header>

    <div class="main-layout">
      <!-- 侧边栏 -->
      <aside class="sidebar" id="sidebar">
        <div class="sidebar-content">
          <div class="search-box">
            <input type="text" placeholder="搜索文档..." id="searchInput" onkeyup="searchDocs()">
            <span class="search-icon">🔍</span>
          </div>
          <nav class="doc-nav">
            
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">📚</span>
          基础概念
        </h3>
        <ul class="category-docs">
          <li><a href="01-React简介.html" class="doc-link">React简介</a></li><li><a href="02-环境搭建.html" class="doc-link">环境搭建</a></li><li><a href="03-JSX语法.html" class="doc-link">JSX语法</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">🧩</span>
          组件开发
        </h3>
        <ul class="category-docs">
          <li><a href="04-组件基础.html" class="doc-link">组件基础</a></li><li><a href="05-Props与State.html" class="doc-link">Props与State</a></li><li><a href="06-事件处理.html" class="doc-link">事件处理</a></li><li><a href="07-条件渲染.html" class="doc-link">条件渲染</a></li><li><a href="08-列表渲染.html" class="doc-link">列表渲染</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">🎣</span>
          Hooks API
        </h3>
        <ul class="category-docs">
          <li><a href="09-Hooks概述.html" class="doc-link">Hooks概述</a></li><li><a href="10-useState.html" class="doc-link">useState</a></li><li><a href="11-useEffect.html" class="doc-link">useEffect</a></li><li><a href="12-useContext.html" class="doc-link">useContext</a></li><li><a href="13-useReducer.html" class="doc-link">useReducer</a></li><li><a href="14-useMemo和useCallback.html" class="doc-link">useMemo和useCallback</a></li><li><a href="15-useRef.html" class="doc-link">useRef</a></li><li><a href="16-自定义Hooks.html" class="doc-link">自定义Hooks</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">🔄</span>
          生命周期
        </h3>
        <ul class="category-docs">
          <li><a href="17-生命周期方法.html" class="doc-link">生命周期方法</a></li><li><a href="18-副作用处理.html" class="doc-link">副作用处理</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">🎨</span>
          样式与UI
        </h3>
        <ul class="category-docs">
          <li><a href="19-样式处理.html" class="doc-link">样式处理</a></li><li><a href="20-动画效果.html" class="doc-link">动画效果</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">🗺️</span>
          路由管理
        </h3>
        <ul class="category-docs">
          <li><a href="21-React-Router.html" class="doc-link">React-Router</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">📦</span>
          状态管理
        </h3>
        <ul class="category-docs">
          <li><a href="22-Context-API.html" class="doc-link">Context-API</a></li><li><a href="23-Redux集成.html" class="doc-link">Redux集成</a></li><li><a href="24-Zustand状态管理.html" class="doc-link">Zustand状态管理</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">🚀</span>
          性能优化
        </h3>
        <ul class="category-docs">
          <li><a href="25-性能优化技巧.html" class="doc-link">性能优化技巧</a></li><li><a href="26-代码分割.html" class="doc-link">代码分割</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">🧪</span>
          测试
        </h3>
        <ul class="category-docs">
          <li><a href="27-单元测试.html" class="doc-link">单元测试</a></li><li><a href="28-集成测试.html" class="doc-link">集成测试</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">🏗️</span>
          构建与部署
        </h3>
        <ul class="category-docs">
          <li><a href="29-项目构建.html" class="doc-link">项目构建</a></li><li><a href="30-生产部署.html" class="doc-link">生产部署</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">🛠️</span>
          开发工具
        </h3>
        <ul class="category-docs">
          <li><a href="31-开发者工具.html" class="doc-link">开发者工具</a></li><li><a href="32-调试技巧.html" class="doc-link">调试技巧</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">📖</span>
          API参考
        </h3>
        <ul class="category-docs">
          <li><a href="33-React-API完整参考.html" class="doc-link">React-API完整参考</a></li><li><a href="34-DOM元素属性.html" class="doc-link">DOM元素属性</a></li><li><a href="35-合成事件.html" class="doc-link">合成事件</a></li><li><a href="React-Hooks完整参考.html" class="doc-link">React-Hooks完整参考</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">💡</span>
          最佳实践
        </h3>
        <ul class="category-docs">
          <li><a href="36-编码规范.html" class="doc-link">编码规范</a></li><li><a href="37-项目架构.html" class="doc-link">项目架构</a></li><li><a href="38-常见问题.html" class="doc-link">常见问题</a></li>
        </ul>
      </div>
          </nav>
        </div>
      </aside>

      <!-- 主内容区 -->
      <main class="content">
        <article class="doc-article">
          <div class="doc-header">
            <div class="breadcrumb">
              <a href="index.html">首页</a>
              <span class="separator">></span>
              <span class="current">React-Hooks完整参考</span>
            </div>
            <h1 class="doc-title">React-Hooks完整参考</h1>
            <div class="doc-meta">
              <span class="category" style="background: #fbc2eb">
                📖 API参考
              </span>
            </div>
          </div>
          
          <div class="doc-content">
            <h1>React Hooks 完整参考</h1>
<p>本文档提供React所有官方Hooks的详细参考，包括入参、出参、使用规则、注意事项和使用场景。</p>
<h2>目录</h2>
<h3>基础 Hooks</h3>
<ul>
<li><a href="#usestate">useState</a></li>
<li><a href="#useeffect">useEffect</a></li>
<li><a href="#usecontext">useContext</a></li>
</ul>
<h3>额外 Hooks</h3>
<ul>
<li><a href="#usereducer">useReducer</a></li>
<li><a href="#usecallback">useCallback</a></li>
<li><a href="#usememo">useMemo</a></li>
<li><a href="#useref">useRef</a></li>
<li><a href="#useimperativehandle">useImperativeHandle</a></li>
<li><a href="#uselayouteffect">useLayoutEffect</a></li>
<li><a href="#usedebugvalue">useDebugValue</a></li>
</ul>
<h3>React 18+ Hooks</h3>
<ul>
<li><a href="#useid">useId</a></li>
<li><a href="#usetransition">useTransition</a></li>
<li><a href="#usedeferredvalue">useDeferredValue</a></li>
<li><a href="#usesyncexternalstore">useSyncExternalStore</a></li>
<li><a href="#useinsertioneffect">useInsertionEffect</a></li>
</ul>
<hr>
<h2>useState</h2>
<p>管理组件内部状态的Hook。</p>
<h3>语法</h3>
<pre><code class="language-typescript">const [state, setState] = useState&lt;T&gt;(initialState: T | (() =&gt; T))
</code></pre>
<h3>参数</h3>
<ul>
<li><strong>initialState</strong>: <code>T | (() =&gt; T)</code><ul>
<li>状态的初始值</li>
<li>可以是值或返回初始值的函数</li>
<li>函数只在初始渲染时调用一次</li>
</ul>
</li>
</ul>
<h3>返回值</h3>
<p>返回一个包含两个元素的数组：</p>
<ul>
<li><strong>state</strong>: <code>T</code> - 当前状态值</li>
<li><strong>setState</strong>: <code>(newState: T | ((prevState: T) =&gt; T)) =&gt; void</code> - 更新状态的函数</li>
</ul>
<h3>使用规则</h3>
<ol>
<li>只能在函数组件或自定义Hook中调用</li>
<li>不能在循环、条件语句或嵌套函数中调用</li>
<li>必须在组件的顶层调用</li>
</ol>
<h3>使用场景</h3>
<ul>
<li>管理组件的本地状态</li>
<li>表单输入值管理</li>
<li>开关状态控制</li>
<li>计数器功能</li>
</ul>
<h3>代码示例</h3>
<pre><code class="language-jsx">// 基础用法
function Counter() {
  const [count, setCount] = useState(0)

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;
      &lt;button onClick={() =&gt; setCount(prev =&gt; prev - 1)}&gt;-&lt;/button&gt;
    &lt;/div&gt;
  )
}

// 惰性初始化
function ExpensiveComponent() {
  const [data, setData] = useState(() =&gt; {
    // 只在初始渲染时执行
    return computeExpensiveValue()
  })

  return &lt;div&gt;{data}&lt;/div&gt;
}

// 对象状态管理
function UserForm() {
  const [user, setUser] = useState({
    name: &#39;&#39;,
    email: &#39;&#39;,
    age: 0
  })

  const updateUser = (field, value) =&gt; {
    setUser(prev =&gt; ({
      ...prev,
      [field]: value
    }))
  }

  return (
    &lt;form&gt;
      &lt;input 
        value={user.name}
        onChange={(e) =&gt; updateUser(&#39;name&#39;, e.target.value)}
        placeholder=&quot;Name&quot;
      /&gt;
      &lt;input 
        value={user.email}
        onChange={(e) =&gt; updateUser(&#39;email&#39;, e.target.value)}
        placeholder=&quot;Email&quot;
      /&gt;
    &lt;/form&gt;
  )
}
</code></pre>
<h3>注意事项</h3>
<ol>
<li><strong>状态更新是异步的</strong> - setState后立即访问state可能得到旧值</li>
<li><strong>状态更新会触发重新渲染</strong> - 确保状态确实需要更新</li>
<li><strong>对象和数组需要创建新的引用</strong> - React使用Object.is进行比较</li>
<li><strong>函数式更新</strong> - 当新状态依赖旧状态时，使用函数式更新更安全</li>
</ol>
<hr>
<h2>useEffect</h2>
<p>处理副作用的Hook，如数据获取、订阅、手动DOM操作等。</p>
<h3>语法</h3>
<pre><code class="language-typescript">useEffect(
  effect: () =&gt; void | (() =&gt; void),
  deps?: readonly unknown[]
): void
</code></pre>
<h3>参数</h3>
<ul>
<li><strong>effect</strong>: <code>() =&gt; void | (() =&gt; void)</code><ul>
<li>副作用函数</li>
<li>可以返回清理函数</li>
</ul>
</li>
<li><strong>deps</strong>: <code>readonly unknown[]</code> (可选)<ul>
<li>依赖数组</li>
<li>只有依赖项变化时才重新执行effect</li>
<li>空数组表示只在挂载和卸载时执行</li>
<li>不传表示每次渲染都执行</li>
</ul>
</li>
</ul>
<h3>返回值</h3>
<p>无返回值</p>
<h3>使用规则</h3>
<ol>
<li>只能在函数组件或自定义Hook中调用</li>
<li>必须在组件的顶层调用</li>
<li>依赖数组中必须包含effect中使用的所有响应式值</li>
</ol>
<h3>使用场景</h3>
<ul>
<li>数据获取和API调用</li>
<li>事件监听器的添加和移除</li>
<li>定时器的创建和清理</li>
<li>订阅外部数据源</li>
<li>手动DOM操作</li>
</ul>
<h3>代码示例</h3>
<pre><code class="language-jsx">// 数据获取
function UserProfile({ userId }) {
  const [user, setUser] = useState(null)
  const [loading, setLoading] = useState(true)

  useEffect(() =&gt; {
    let cancelled = false

    const fetchUser = async () =&gt; {
      try {
        setLoading(true)
        const response = await fetch(`/api/users/${userId}`)
        const userData = await response.json()
        
        if (!cancelled) {
          setUser(userData)
        }
      } catch (error) {
        if (!cancelled) {
          console.error(&#39;Failed to fetch user:&#39;, error)
        }
      } finally {
        if (!cancelled) {
          setLoading(false)
        }
      }
    }

    fetchUser()

    return () =&gt; {
      cancelled = true
    }
  }, [userId])

  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;
  if (!user) return &lt;div&gt;User not found&lt;/div&gt;

  return &lt;div&gt;{user.name}&lt;/div&gt;
}

// 事件监听器
function WindowWidth() {
  const [width, setWidth] = useState(window.innerWidth)

  useEffect(() =&gt; {
    const handleResize = () =&gt; {
      setWidth(window.innerWidth)
    }

    window.addEventListener(&#39;resize&#39;, handleResize)

    return () =&gt; {
      window.removeEventListener(&#39;resize&#39;, handleResize)
    }
  }, [])

  return &lt;div&gt;Window width: {width}px&lt;/div&gt;
}

// 定时器
function Timer() {
  const [time, setTime] = useState(0)
  const [isRunning, setIsRunning] = useState(false)

  useEffect(() =&gt; {
    let intervalId

    if (isRunning) {
      intervalId = setInterval(() =&gt; {
        setTime(time =&gt; time + 1)
      }, 1000)
    }

    return () =&gt; {
      if (intervalId) {
        clearInterval(intervalId)
      }
    }
  }, [isRunning])

  return (
    &lt;div&gt;
      &lt;div&gt;Time: {time}s&lt;/div&gt;
      &lt;button onClick={() =&gt; setIsRunning(!isRunning)}&gt;
        {isRunning ? &#39;Stop&#39; : &#39;Start&#39;}
      &lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<h3>注意事项</h3>
<ol>
<li><strong>清理函数</strong> - 始终清理副作用以避免内存泄漏</li>
<li><strong>依赖数组</strong> - 确保包含所有依赖项，使用ESLint插件检查</li>
<li><strong>无限循环</strong> - 避免在effect中更新依赖项导致的无限循环</li>
<li><strong>取消机制</strong> - 对于异步操作，实现取消机制防止在组件卸载后更新状态</li>
</ol>
<hr>
<h2>useContext</h2>
<p>消费Context值的Hook。</p>
<h3>语法</h3>
<pre><code class="language-typescript">const value = useContext&lt;T&gt;(context: React.Context&lt;T&gt;): T
</code></pre>
<h3>参数</h3>
<ul>
<li><strong>context</strong>: <code>React.Context&lt;T&gt;</code><ul>
<li>通过<code>createContext</code>创建的Context对象</li>
</ul>
</li>
</ul>
<h3>返回值</h3>
<ul>
<li><strong>value</strong>: <code>T</code> - Context的当前值</li>
</ul>
<h3>使用规则</h3>
<ol>
<li>只能在函数组件或自定义Hook中调用</li>
<li>必须在组件的顶层调用</li>
<li>组件必须被对应的Context.Provider包裹</li>
</ol>
<h3>使用场景</h3>
<ul>
<li>全局状态管理</li>
<li>主题切换</li>
<li>用户认证信息</li>
<li>语言国际化</li>
<li>避免prop drilling</li>
</ul>
<h3>代码示例</h3>
<pre><code class="language-jsx">// 创建Context
const ThemeContext = createContext()
const UserContext = createContext()

// Provider组件
function App() {
  const [theme, setTheme] = useState(&#39;light&#39;)
  const [user, setUser] = useState(null)

  return (
    &lt;ThemeContext.Provider value={{ theme, setTheme }}&gt;
      &lt;UserContext.Provider value={{ user, setUser }}&gt;
        &lt;Header /&gt;
        &lt;MainContent /&gt;
      &lt;/UserContext.Provider&gt;
    &lt;/ThemeContext.Provider&gt;
  )
}

// 消费Context
function Header() {
  const { theme, setTheme } = useContext(ThemeContext)
  const { user } = useContext(UserContext)

  return (
    &lt;header className={`header ${theme}`}&gt;
      &lt;h1&gt;My App&lt;/h1&gt;
      {user &amp;&amp; &lt;span&gt;Welcome, {user.name}&lt;/span&gt;}
      &lt;button onClick={() =&gt; setTheme(theme === &#39;light&#39; ? &#39;dark&#39; : &#39;light&#39;)}&gt;
        Toggle Theme
      &lt;/button&gt;
    &lt;/header&gt;
  )
}

// 自定义Hook封装Context
function useTheme() {
  const context = useContext(ThemeContext)
  if (!context) {
    throw new Error(&#39;useTheme must be used within a ThemeProvider&#39;)
  }
  return context
}

function useUser() {
  const context = useContext(UserContext)
  if (!context) {
    throw new Error(&#39;useUser must be used within a UserProvider&#39;)
  }
  return context
}

// 使用自定义Hook
function Profile() {
  const { theme } = useTheme()
  const { user, setUser } = useUser()

  return (
    &lt;div className={`profile ${theme}`}&gt;
      {user ? (
        &lt;div&gt;
          &lt;p&gt;Name: {user.name}&lt;/p&gt;
          &lt;button onClick={() =&gt; setUser(null)}&gt;Logout&lt;/button&gt;
        &lt;/div&gt;
      ) : (
        &lt;button onClick={() =&gt; setUser({ name: &#39;John&#39; })}&gt;Login&lt;/button&gt;
      )}
    &lt;/div&gt;
  )
}
</code></pre>
<h3>注意事项</h3>
<ol>
<li><strong>Provider层级</strong> - 确保组件在正确的Provider内部</li>
<li><strong>Context默认值</strong> - 在没有Provider时的fallback值</li>
<li><strong>性能考虑</strong> - Context值变化会导致所有消费者重新渲染</li>
<li><strong>类型安全</strong> - 在TypeScript中正确定义Context类型</li>
</ol>
<hr>
<h2>useReducer</h2>
<p>useState的替代方案，用于管理复杂的状态逻辑。</p>
<h3>语法</h3>
<pre><code class="language-typescript">const [state, dispatch] = useReducer&lt;R&gt;(
  reducer: (state: ReducerState&lt;R&gt;, action: ReducerAction&lt;R&gt;) =&gt; ReducerState&lt;R&gt;,
  initialArg: ReducerState&lt;R&gt;,
  init?: (initialArg: ReducerState&lt;R&gt;) =&gt; ReducerState&lt;R&gt;
): [ReducerState&lt;R&gt;, Dispatch&lt;ReducerAction&lt;R&gt;&gt;]
</code></pre>
<h3>参数</h3>
<ul>
<li><strong>reducer</strong>: <code>(state, action) =&gt; newState</code><ul>
<li>纯函数，接收当前状态和action，返回新状态</li>
</ul>
</li>
<li><strong>initialArg</strong>: 初始状态值</li>
<li><strong>init</strong>: <code>(initialArg) =&gt; initialState</code> (可选)<ul>
<li>惰性初始化函数</li>
</ul>
</li>
</ul>
<h3>返回值</h3>
<p>返回包含两个元素的数组：</p>
<ul>
<li><strong>state</strong>: 当前状态</li>
<li><strong>dispatch</strong>: 派发action的函数</li>
</ul>
<h3>使用规则</h3>
<ol>
<li>只能在函数组件或自定义Hook中调用</li>
<li>必须在组件的顶层调用</li>
<li>reducer函数必须是纯函数</li>
</ol>
<h3>使用场景</h3>
<ul>
<li>复杂的状态逻辑</li>
<li>状态更新依赖多个子值</li>
<li>下一个状态依赖前一个状态</li>
<li>状态管理需要更好的可预测性</li>
</ul>
<h3>代码示例</h3>
<pre><code class="language-jsx">// 计数器示例
const initialState = { count: 0 }

function counterReducer(state, action) {
  switch (action.type) {
    case &#39;increment&#39;:
      return { count: state.count + 1 }
    case &#39;decrement&#39;:
      return { count: state.count - 1 }
    case &#39;reset&#39;:
      return initialState
    case &#39;set&#39;:
      return { count: action.payload }
    default:
      throw new Error(`Unknown action type: ${action.type}`)
  }
}

function Counter() {
  const [state, dispatch] = useReducer(counterReducer, initialState)

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {state.count}&lt;/p&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#39;increment&#39; })}&gt;+&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#39;decrement&#39; })}&gt;-&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#39;reset&#39; })}&gt;Reset&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#39;set&#39;, payload: 10 })}&gt;
        Set to 10
      &lt;/button&gt;
    &lt;/div&gt;
  )
}

// 表单管理示例
const formInitialState = {
  name: &#39;&#39;,
  email: &#39;&#39;,
  errors: {},
  isSubmitting: false
}

function formReducer(state, action) {
  switch (action.type) {
    case &#39;SET_FIELD&#39;:
      return {
        ...state,
        [action.field]: action.value,
        errors: {
          ...state.errors,
          [action.field]: null
        }
      }
    case &#39;SET_ERROR&#39;:
      return {
        ...state,
        errors: {
          ...state.errors,
          [action.field]: action.error
        }
      }
    case &#39;SET_SUBMITTING&#39;:
      return {
        ...state,
        isSubmitting: action.isSubmitting
      }
    case &#39;RESET_FORM&#39;:
      return formInitialState
    default:
      return state
  }
}

function ContactForm() {
  const [state, dispatch] = useReducer(formReducer, formInitialState)

  const handleSubmit = async (e) =&gt; {
    e.preventDefault()
    
    // 验证
    if (!state.name) {
      dispatch({ type: &#39;SET_ERROR&#39;, field: &#39;name&#39;, error: &#39;Name is required&#39; })
      return
    }
    
    if (!state.email) {
      dispatch({ type: &#39;SET_ERROR&#39;, field: &#39;email&#39;, error: &#39;Email is required&#39; })
      return
    }

    // 提交
    dispatch({ type: &#39;SET_SUBMITTING&#39;, isSubmitting: true })
    
    try {
      await submitForm({ name: state.name, email: state.email })
      dispatch({ type: &#39;RESET_FORM&#39; })
    } catch (error) {
      dispatch({ type: &#39;SET_ERROR&#39;, field: &#39;submit&#39;, error: error.message })
    } finally {
      dispatch({ type: &#39;SET_SUBMITTING&#39;, isSubmitting: false })
    }
  }

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input
        type=&quot;text&quot;
        value={state.name}
        onChange={(e) =&gt; dispatch({ 
          type: &#39;SET_FIELD&#39;, 
          field: &#39;name&#39;, 
          value: e.target.value 
        })}
        placeholder=&quot;Name&quot;
      /&gt;
      {state.errors.name &amp;&amp; &lt;span&gt;{state.errors.name}&lt;/span&gt;}

      &lt;input
        type=&quot;email&quot;
        value={state.email}
        onChange={(e) =&gt; dispatch({ 
          type: &#39;SET_FIELD&#39;, 
          field: &#39;email&#39;, 
          value: e.target.value 
        })}
        placeholder=&quot;Email&quot;
      /&gt;
      {state.errors.email &amp;&amp; &lt;span&gt;{state.errors.email}&lt;/span&gt;}

      &lt;button type=&quot;submit&quot; disabled={state.isSubmitting}&gt;
        {state.isSubmitting ? &#39;Submitting...&#39; : &#39;Submit&#39;}
      &lt;/button&gt;
      
      {state.errors.submit &amp;&amp; &lt;div&gt;{state.errors.submit}&lt;/div&gt;}
    &lt;/form&gt;
  )
}
</code></pre>
<h3>注意事项</h3>
<ol>
<li><strong>纯函数</strong> - reducer必须是纯函数，不能有副作用</li>
<li><strong>不可变更新</strong> - 必须返回新的状态对象</li>
<li><strong>action设计</strong> - 设计清晰的action类型和结构</li>
<li><strong>性能</strong> - 复杂状态时比useState更高效</li>
</ol>
<hr>
<h2>useCallback</h2>
<p>返回一个记忆化的回调函数。</p>
<h3>语法</h3>
<pre><code class="language-typescript">const memoizedCallback = useCallback&lt;T&gt;(
  callback: T,
  deps: readonly unknown[]
): T
</code></pre>
<h3>参数</h3>
<ul>
<li><strong>callback</strong>: 要记忆化的函数</li>
<li><strong>deps</strong>: 依赖数组，只有当依赖项改变时才会返回新的函数</li>
</ul>
<h3>返回值</h3>
<ul>
<li><strong>memoizedCallback</strong>: 记忆化的回调函数</li>
</ul>
<h3>使用规则</h3>
<ol>
<li>只能在函数组件或自定义Hook中调用</li>
<li>必须在组件的顶层调用</li>
<li>依赖数组必须包含回调函数中使用的所有响应式值</li>
</ol>
<h3>使用场景</h3>
<ul>
<li>防止子组件不必要的重新渲染</li>
<li>作为其他Hook的依赖项</li>
<li>传递给使用了React.memo的子组件</li>
<li>昂贵的函数计算</li>
</ul>
<h3>代码示例</h3>
<pre><code class="language-jsx">// 防止子组件重新渲染
const ExpensiveChild = React.memo(({ onClick, data }) =&gt; {
  console.log(&#39;ExpensiveChild rendered&#39;)
  
  return (
    &lt;div&gt;
      &lt;button onClick={onClick}&gt;Click me&lt;/button&gt;
      &lt;div&gt;{data.map(item =&gt; &lt;div key={item.id}&gt;{item.name}&lt;/div&gt;)}&lt;/div&gt;
    &lt;/div&gt;
  )
})

function Parent() {
  const [count, setCount] = useState(0)
  const [items, setItems] = useState([])

  // 没有useCallback，每次渲染都会创建新函数
  const handleClick = () =&gt; {
    console.log(&#39;Button clicked&#39;)
  }

  // 使用useCallback，只有当依赖项改变时才创建新函数
  const handleClickMemoized = useCallback(() =&gt; {
    console.log(&#39;Button clicked&#39;, count)
  }, [count])

  const addItem = useCallback(() =&gt; {
    setItems(prev =&gt; [...prev, { id: Date.now(), name: `Item ${prev.length}` }])
  }, [])

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Count: {count}&lt;/button&gt;
      &lt;button onClick={addItem}&gt;Add Item&lt;/button&gt;
      
      {/* 这个会导致ExpensiveChild每次都重新渲染 */}
      &lt;ExpensiveChild onClick={handleClick} data={items} /&gt;
      
      {/* 这个只有在count改变时才会重新渲染 */}
      &lt;ExpensiveChild onClick={handleClickMemoized} data={items} /&gt;
    &lt;/div&gt;
  )
}

// 作为useEffect的依赖
function SearchComponent() {
  const [query, setQuery] = useState(&#39;&#39;)
  const [results, setResults] = useState([])

  const searchFunction = useCallback(async (searchQuery) =&gt; {
    if (!searchQuery) {
      setResults([])
      return
    }

    try {
      const response = await fetch(`/api/search?q=${searchQuery}`)
      const data = await response.json()
      setResults(data)
    } catch (error) {
      console.error(&#39;Search failed:&#39;, error)
    }
  }, [])

  useEffect(() =&gt; {
    const timeoutId = setTimeout(() =&gt; {
      searchFunction(query)
    }, 500)

    return () =&gt; clearTimeout(timeoutId)
  }, [query, searchFunction])

  return (
    &lt;div&gt;
      &lt;input
        type=&quot;text&quot;
        value={query}
        onChange={(e) =&gt; setQuery(e.target.value)}
        placeholder=&quot;Search...&quot;
      /&gt;
      &lt;ul&gt;
        {results.map(result =&gt; (
          &lt;li key={result.id}&gt;{result.title}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  )
}

// 自定义Hook中的useCallback
function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue)

  const toggle = useCallback(() =&gt; {
    setValue(prev =&gt; !prev)
  }, [])

  const setTrue = useCallback(() =&gt; {
    setValue(true)
  }, [])

  const setFalse = useCallback(() =&gt; {
    setValue(false)
  }, [])

  return { value, toggle, setTrue, setFalse }
}
</code></pre>
<h3>注意事项</h3>
<ol>
<li><strong>不要过度使用</strong> - 只在真正需要时使用，否则可能适得其反</li>
<li><strong>依赖数组</strong> - 确保包含所有依赖项</li>
<li><strong>引用相等性</strong> - useCallback保证引用相等性，不是值相等性</li>
<li><strong>与React.memo配合</strong> - 通常与React.memo一起使用才有意义</li>
</ol>
<hr>
<h2>useMemo</h2>
<p>返回一个记忆化的值，只有当依赖项改变时才重新计算。</p>
<h3>语法</h3>
<pre><code class="language-typescript">const memoizedValue = useMemo&lt;T&gt;(
  factory: () =&gt; T,
  deps: readonly unknown[]
): T
</code></pre>
<h3>参数</h3>
<ul>
<li><strong>factory</strong>: <code>() =&gt; T</code> - 返回要记忆化值的函数</li>
<li><strong>deps</strong>: <code>readonly unknown[]</code> - 依赖数组</li>
</ul>
<h3>返回值</h3>
<ul>
<li><strong>memoizedValue</strong>: <code>T</code> - 记忆化的值</li>
</ul>
<h3>使用规则</h3>
<ol>
<li>只能在函数组件或自定义Hook中调用</li>
<li>必须在组件的顶层调用</li>
<li>依赖数组必须包含factory函数中使用的所有响应式值</li>
</ol>
<h3>使用场景</h3>
<ul>
<li>昂贵的计算操作</li>
<li>复杂对象的创建</li>
<li>避免在每次渲染时重新计算相同的值</li>
<li>作为其他Hook的依赖项</li>
</ul>
<h3>代码示例</h3>
<pre><code class="language-jsx">// 昂贵的计算
function ExpensiveComponent({ items, filter }) {
  // 没有useMemo，每次渲染都会重新计算
  const expensiveValue = computeExpensiveValue(items, filter)

  // 使用useMemo，只有当依赖项改变时才重新计算
  const memoizedExpensiveValue = useMemo(() =&gt; {
    console.log(&#39;Computing expensive value...&#39;)
    return computeExpensiveValue(items, filter)
  }, [items, filter])

  return &lt;div&gt;{memoizedExpensiveValue}&lt;/div&gt;
}

function computeExpensiveValue(items, filter) {
  return items
    .filter(item =&gt; item.category === filter)
    .reduce((sum, item) =&gt; sum + item.value, 0)
}

// 复杂对象创建
function UserList({ users, sortBy, filterBy }) {
  const processedUsers = useMemo(() =&gt; {
    console.log(&#39;Processing users...&#39;)
    
    let filtered = users.filter(user =&gt; 
      filterBy ? user.role === filterBy : true
    )

    let sorted = filtered.sort((a, b) =&gt; {
      switch (sortBy) {
        case &#39;name&#39;:
          return a.name.localeCompare(b.name)
        case &#39;age&#39;:
          return a.age - b.age
        case &#39;email&#39;:
          return a.email.localeCompare(b.email)
        default:
          return 0
      }
    })

    return sorted.map(user =&gt; ({
      ...user,
      displayName: `${user.name} (${user.role})`
    }))
  }, [users, sortBy, filterBy])

  return (
    &lt;ul&gt;
      {processedUsers.map(user =&gt; (
        &lt;li key={user.id}&gt;{user.displayName}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  )
}

// 避免子组件重新渲染
const ChildComponent = React.memo(({ config }) =&gt; {
  console.log(&#39;ChildComponent rendered&#39;)
  return &lt;div&gt;{config.title}&lt;/div&gt;
})

function ParentComponent({ title, count }) {
  // 没有useMemo，每次渲染都会创建新对象
  const config = { title, timestamp: Date.now() }

  // 使用useMemo，只有title改变时才创建新对象
  const memoizedConfig = useMemo(() =&gt; ({
    title,
    timestamp: Date.now()
  }), [title])

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Count: {count}&lt;/button&gt;
      {/* 每次都会重新渲染 */}
      &lt;ChildComponent config={config} /&gt;
      {/* 只有title改变时才重新渲染 */}
      &lt;ChildComponent config={memoizedConfig} /&gt;
    &lt;/div&gt;
  )
}

// 作为其他Hook的依赖项
function SearchWithCache({ query, options }) {
  const searchParams = useMemo(() =&gt; ({
    query: query.trim().toLowerCase(),
    includeArchived: options.includeArchived,
    sortBy: options.sortBy
  }), [query, options.includeArchived, options.sortBy])

  const [results, setResults] = useState([])

  useEffect(() =&gt; {
    const searchData = async () =&gt; {
      try {
        const response = await fetch(&#39;/api/search&#39;, {
          method: &#39;POST&#39;,
          headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },
          body: JSON.stringify(searchParams)
        })
        const data = await response.json()
        setResults(data)
      } catch (error) {
        console.error(&#39;Search failed:&#39;, error)
      }
    }

    if (searchParams.query) {
      searchData()
    } else {
      setResults([])
    }
  }, [searchParams])

  return (
    &lt;ul&gt;
      {results.map(result =&gt; (
        &lt;li key={result.id}&gt;{result.title}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  )
}
</code></pre>
<h3>注意事项</h3>
<ol>
<li><strong>不要过度使用</strong> - 记忆化本身也有开销</li>
<li><strong>引用类型</strong> - 对于原始值，useMemo通常没有必要</li>
<li><strong>依赖数组</strong> - 确保包含所有依赖项</li>
<li><strong>性能权衡</strong> - 只在真正昂贵的计算时使用</li>
</ol>
<hr>
<h2>useRef</h2>
<p>返回一个可变的ref对象，用于访问DOM元素或存储可变值。</p>
<h3>语法</h3>
<pre><code class="language-typescript">const refContainer = useRef&lt;T&gt;(initialValue: T): React.MutableRefObject&lt;T&gt;
</code></pre>
<h3>参数</h3>
<ul>
<li><strong>initialValue</strong>: <code>T</code> - ref的初始值</li>
</ul>
<h3>返回值</h3>
<ul>
<li><strong>refContainer</strong>: <code>React.MutableRefObject&lt;T&gt;</code> - 包含current属性的ref对象</li>
</ul>
<h3>使用规则</h3>
<ol>
<li>只能在函数组件或自定义Hook中调用</li>
<li>必须在组件的顶层调用</li>
<li>更改ref.current不会触发重新渲染</li>
</ol>
<h3>使用场景</h3>
<ul>
<li>访问DOM元素</li>
<li>存储组件实例</li>
<li>保存可变值而不触发重新渲染</li>
<li>存储定时器ID、订阅等</li>
<li>获取上一次的状态值</li>
</ul>
<h3>代码示例</h3>
<pre><code class="language-jsx">// 访问DOM元素
function TextInputWithFocusButton() {
  const inputEl = useRef(null)

  const onButtonClick = () =&gt; {
    // `current` 指向已挂载到 DOM 上的文本输入元素
    inputEl.current.focus()
  }

  return (
    &lt;div&gt;
      &lt;input ref={inputEl} type=&quot;text&quot; /&gt;
      &lt;button onClick={onButtonClick}&gt;Focus the input&lt;/button&gt;
    &lt;/div&gt;
  )
}

// 存储可变值
function Timer() {
  const [count, setCount] = useState(0)
  const intervalRef = useRef(null)

  const startTimer = () =&gt; {
    if (intervalRef.current !== null) return

    intervalRef.current = setInterval(() =&gt; {
      setCount(c =&gt; c + 1)
    }, 1000)
  }

  const stopTimer = () =&gt; {
    if (intervalRef.current !== null) {
      clearInterval(intervalRef.current)
      intervalRef.current = null
    }
  }

  useEffect(() =&gt; {
    return () =&gt; {
      // 组件卸载时清理定时器
      if (intervalRef.current !== null) {
        clearInterval(intervalRef.current)
      }
    }
  }, [])

  return (
    &lt;div&gt;
      &lt;div&gt;Count: {count}&lt;/div&gt;
      &lt;button onClick={startTimer}&gt;Start&lt;/button&gt;
      &lt;button onClick={stopTimer}&gt;Stop&lt;/button&gt;
    &lt;/div&gt;
  )
}

// 获取上一次的值
function usePrevious(value) {
  const ref = useRef()
  
  useEffect(() =&gt; {
    ref.current = value
  })
  
  return ref.current
}

function Counter() {
  const [count, setCount] = useState(0)
  const prevCount = usePrevious(count)

  return (
    &lt;div&gt;
      &lt;h1&gt;Now: {count}, before: {prevCount}&lt;/h1&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  )
}

// 存储回调函数的最新版本
function useEventCallback(fn) {
  const ref = useRef()
  
  useEffect(() =&gt; {
    ref.current = fn
  })

  return useCallback((...args) =&gt; {
    const f = ref.current
    return f(...args)
  }, [])
}

function Chat({ roomId }) {
  const [message, setMessage] = useState(&#39;&#39;)

  const handleSendMessage = useEventCallback(() =&gt; {
    sendMessage(roomId, message)
    setMessage(&#39;&#39;)
  })

  useEffect(() =&gt; {
    const socket = createSocket(roomId)
    
    socket.on(&#39;message&#39;, handleSendMessage)
    
    return () =&gt; socket.disconnect()
  }, [roomId, handleSendMessage])

  return (
    &lt;div&gt;
      &lt;input
        value={message}
        onChange={e =&gt; setMessage(e.target.value)}
      /&gt;
      &lt;button onClick={handleSendMessage}&gt;Send&lt;/button&gt;
    &lt;/div&gt;
  )
}

// 滚动到底部
function ChatMessages({ messages }) {
  const messagesEndRef = useRef(null)

  const scrollToBottom = () =&gt; {
    messagesEndRef.current?.scrollIntoView({ behavior: &quot;smooth&quot; })
  }

  useEffect(() =&gt; {
    scrollToBottom()
  }, [messages])

  return (
    &lt;div className=&quot;messages-container&quot;&gt;
      {messages.map(message =&gt; (
        &lt;div key={message.id} className=&quot;message&quot;&gt;
          {message.text}
        &lt;/div&gt;
      ))}
      &lt;div ref={messagesEndRef} /&gt;
    &lt;/div&gt;
  )
}

// 测量DOM元素
function MeasureComponent() {
  const elementRef = useRef(null)
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 })

  useEffect(() =&gt; {
    const measureElement = () =&gt; {
      if (elementRef.current) {
        const { offsetWidth, offsetHeight } = elementRef.current
        setDimensions({ width: offsetWidth, height: offsetHeight })
      }
    }

    measureElement()

    const resizeObserver = new ResizeObserver(measureElement)
    if (elementRef.current) {
      resizeObserver.observe(elementRef.current)
    }

    return () =&gt; resizeObserver.disconnect()
  }, [])

  return (
    &lt;div&gt;
      &lt;div ref={elementRef} style={{ resize: &#39;both&#39;, overflow: &#39;auto&#39;, border: &#39;1px solid&#39; }}&gt;
        &lt;p&gt;调整我的大小&lt;/p&gt;
        &lt;p&gt;Width: {dimensions.width}px&lt;/p&gt;
        &lt;p&gt;Height: {dimensions.height}px&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<h3>注意事项</h3>
<ol>
<li><strong>不触发渲染</strong> - 修改ref.current不会触发组件重新渲染</li>
<li><strong>初始化时机</strong> - ref在所有DOM更新后才被设置</li>
<li><strong>函数组件实例</strong> - 不能直接为函数组件设置ref</li>
<li><strong>避免过度使用</strong> - 优先使用声明式方法而不是命令式</li>
</ol>
<hr>
<h2>useImperativeHandle</h2>
<p>自定义ref暴露给父组件的实例值。</p>
<h3>语法</h3>
<pre><code class="language-typescript">useImperativeHandle&lt;T&gt;(
  ref: React.Ref&lt;T&gt;,
  createHandle: () =&gt; T,
  deps?: readonly unknown[]
): void
</code></pre>
<h3>参数</h3>
<ul>
<li><strong>ref</strong>: <code>React.Ref&lt;T&gt;</code> - 从父组件传入的ref</li>
<li><strong>createHandle</strong>: <code>() =&gt; T</code> - 返回要暴露给父组件的对象的函数  </li>
<li><strong>deps</strong>: <code>readonly unknown[]</code> (可选) - 依赖数组</li>
</ul>
<h3>返回值</h3>
<p>无返回值</p>
<h3>使用规则</h3>
<ol>
<li>只能在函数组件或自定义Hook中调用</li>
<li>必须与forwardRef一起使用</li>
<li>必须在组件的顶层调用</li>
</ol>
<h3>使用场景</h3>
<ul>
<li>暴露子组件的方法给父组件</li>
<li>限制暴露的API表面</li>
<li>创建可重用的组件库</li>
<li>封装复杂的DOM操作</li>
</ul>
<h3>代码示例</h3>
<pre><code class="language-jsx">// 基础用法 - 暴露焦点方法
const FancyInput = forwardRef((props, ref) =&gt; {
  const inputRef = useRef()

  useImperativeHandle(ref, () =&gt; ({
    focus: () =&gt; {
      inputRef.current.focus()
    },
    clear: () =&gt; {
      inputRef.current.value = &#39;&#39;
    },
    getValue: () =&gt; {
      return inputRef.current.value
    }
  }))

  return &lt;input ref={inputRef} {...props} /&gt;
})

function Parent() {
  const fancyInputRef = useRef()

  const handleClick = () =&gt; {
    fancyInputRef.current.focus()
  }

  const handleClear = () =&gt; {
    fancyInputRef.current.clear()
  }

  const handleGetValue = () =&gt; {
    console.log(fancyInputRef.current.getValue())
  }

  return (
    &lt;div&gt;
      &lt;FancyInput ref={fancyInputRef} /&gt;
      &lt;button onClick={handleClick}&gt;Focus&lt;/button&gt;
      &lt;button onClick={handleClear}&gt;Clear&lt;/button&gt;
      &lt;button onClick={handleGetValue}&gt;Get Value&lt;/button&gt;
    &lt;/div&gt;
  )
}

// 模态框组件
const Modal = forwardRef(({ children }, ref) =&gt; {
  const [isOpen, setIsOpen] = useState(false)
  const modalRef = useRef()

  useImperativeHandle(ref, () =&gt; ({
    open: () =&gt; setIsOpen(true),
    close: () =&gt; setIsOpen(false),
    toggle: () =&gt; setIsOpen(prev =&gt; !prev),
    isOpen: () =&gt; isOpen,
    focusModal: () =&gt; modalRef.current?.focus()
  }))

  if (!isOpen) return null

  return (
    &lt;div className=&quot;modal-overlay&quot; onClick={() =&gt; setIsOpen(false)}&gt;
      &lt;div 
        ref={modalRef}
        className=&quot;modal-content&quot; 
        onClick={e =&gt; e.stopPropagation()}
        tabIndex={-1}
      &gt;
        {children}
        &lt;button onClick={() =&gt; setIsOpen(false)}&gt;Close&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  )
})

function App() {
  const modalRef = useRef()

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; modalRef.current.open()}&gt;
        Open Modal
      &lt;/button&gt;
      
      &lt;Modal ref={modalRef}&gt;
        &lt;h2&gt;Modal Content&lt;/h2&gt;
        &lt;p&gt;This is a modal dialog.&lt;/p&gt;
      &lt;/Modal&gt;
    &lt;/div&gt;
  )
}

// 视频播放器组件
const VideoPlayer = forwardRef(({ src, ...props }, ref) =&gt; {
  const videoRef = useRef()
  const [isPlaying, setIsPlaying] = useState(false)
  const [currentTime, setCurrentTime] = useState(0)
  const [duration, setDuration] = useState(0)

  useImperativeHandle(ref, () =&gt; ({
    play: () =&gt; {
      videoRef.current.play()
      setIsPlaying(true)
    },
    pause: () =&gt; {
      videoRef.current.pause()
      setIsPlaying(false)
    },
    seek: (time) =&gt; {
      videoRef.current.currentTime = time
      setCurrentTime(time)
    },
    setVolume: (volume) =&gt; {
      videoRef.current.volume = Math.max(0, Math.min(1, volume))
    },
    getCurrentTime: () =&gt; currentTime,
    getDuration: () =&gt; duration,
    isPlaying: () =&gt; isPlaying
  }))

  const handleTimeUpdate = () =&gt; {
    setCurrentTime(videoRef.current.currentTime)
  }

  const handleLoadedMetadata = () =&gt; {
    setDuration(videoRef.current.duration)
  }

  const handlePlay = () =&gt; setIsPlaying(true)
  const handlePause = () =&gt; setIsPlaying(false)

  return (
    &lt;video
      ref={videoRef}
      src={src}
      onTimeUpdate={handleTimeUpdate}
      onLoadedMetadata={handleLoadedMetadata}
      onPlay={handlePlay}
      onPause={handlePause}
      {...props}
    /&gt;
  )
})

function VideoControls() {
  const playerRef = useRef()

  const handlePlayPause = () =&gt; {
    if (playerRef.current.isPlaying()) {
      playerRef.current.pause()
    } else {
      playerRef.current.play()
    }
  }

  const handleSeekForward = () =&gt; {
    const currentTime = playerRef.current.getCurrentTime()
    playerRef.current.seek(currentTime + 10)
  }

  const handleVolumeChange = (e) =&gt; {
    playerRef.current.setVolume(e.target.value / 100)
  }

  return (
    &lt;div&gt;
      &lt;VideoPlayer 
        ref={playerRef}
        src=&quot;/video.mp4&quot;
        controls={false}
      /&gt;
      
      &lt;div className=&quot;custom-controls&quot;&gt;
        &lt;button onClick={handlePlayPause}&gt;Play/Pause&lt;/button&gt;
        &lt;button onClick={handleSeekForward}&gt;+10s&lt;/button&gt;
        &lt;input 
          type=&quot;range&quot; 
          min=&quot;0&quot; 
          max=&quot;100&quot; 
          onChange={handleVolumeChange}
        /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  )
}

// 表单组件
const Form = forwardRef(({ children, onSubmit }, ref) =&gt; {
  const formRef = useRef()
  const fieldsRef = useRef({})

  useImperativeHandle(ref, () =&gt; ({
    submit: () =&gt; {
      formRef.current.requestSubmit()
    },
    reset: () =&gt; {
      formRef.current.reset()
    },
    validate: () =&gt; {
      return formRef.current.checkValidity()
    },
    getFieldValue: (name) =&gt; {
      return fieldsRef.current[name]?.value
    },
    setFieldValue: (name, value) =&gt; {
      if (fieldsRef.current[name]) {
        fieldsRef.current[name].value = value
      }
    },
    focusField: (name) =&gt; {
      fieldsRef.current[name]?.focus()
    }
  }))

  const registerField = (name, element) =&gt; {
    fieldsRef.current[name] = element
  }

  return (
    &lt;form ref={formRef} onSubmit={onSubmit}&gt;
      {React.Children.map(children, child =&gt; 
        React.cloneElement(child, { registerField })
      )}
    &lt;/form&gt;
  )
})

const FormField = ({ name, registerField, ...props }) =&gt; {
  const inputRef = useRef()

  useEffect(() =&gt; {
    if (registerField &amp;&amp; name) {
      registerField(name, inputRef.current)
    }
  }, [name, registerField])

  return &lt;input ref={inputRef} name={name} {...props} /&gt;
}

function FormExample() {
  const formRef = useRef()

  const handleSubmit = (e) =&gt; {
    e.preventDefault()
    console.log(&#39;Username:&#39;, formRef.current.getFieldValue(&#39;username&#39;))
    console.log(&#39;Email:&#39;, formRef.current.getFieldValue(&#39;email&#39;))
  }

  const handleReset = () =&gt; {
    formRef.current.reset()
  }

  const handleFocusUsername = () =&gt; {
    formRef.current.focusField(&#39;username&#39;)
  }

  return (
    &lt;div&gt;
      &lt;Form ref={formRef} onSubmit={handleSubmit}&gt;
        &lt;FormField name=&quot;username&quot; placeholder=&quot;Username&quot; required /&gt;
        &lt;FormField name=&quot;email&quot; type=&quot;email&quot; placeholder=&quot;Email&quot; required /&gt;
        &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
      &lt;/Form&gt;
      
      &lt;button onClick={handleReset}&gt;Reset Form&lt;/button&gt;
      &lt;button onClick={handleFocusUsername}&gt;Focus Username&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<h3>注意事项</h3>
<ol>
<li><strong>forwardRef配合</strong> - 必须与React.forwardRef一起使用</li>
<li><strong>避免过度使用</strong> - 优先使用props和回调函数</li>
<li><strong>API设计</strong> - 设计清晰、一致的暴露接口</li>
<li><strong>类型安全</strong> - 在TypeScript中正确定义ref类型</li>
</ol>
<hr>
<h2>useLayoutEffect</h2>
<p>与useEffect类似，但它在所有DOM变更之后同步调用。</p>
<h3>语法</h3>
<pre><code class="language-typescript">useLayoutEffect(
  effect: () =&gt; void | (() =&gt; void),
  deps?: readonly unknown[]
): void
</code></pre>
<h3>参数</h3>
<ul>
<li><strong>effect</strong>: <code>() =&gt; void | (() =&gt; void)</code> - 副作用函数</li>
<li><strong>deps</strong>: <code>readonly unknown[]</code> (可选) - 依赖数组</li>
</ul>
<h3>返回值</h3>
<p>无返回值</p>
<h3>使用规则</h3>
<ol>
<li>只能在函数组件或自定义Hook中调用</li>
<li>必须在组件的顶层调用</li>
<li>在浏览器执行绘制之前同步运行</li>
</ol>
<h3>使用场景</h3>
<ul>
<li>需要同步读取DOM并进行修改</li>
<li>避免视觉闪烁</li>
<li>测量DOM元素尺寸</li>
<li>需要在浏览器绘制前完成的操作</li>
</ul>
<h3>代码示例</h3>
<pre><code class="language-jsx">// 避免闪烁的工具提示定位
function Tooltip({ children, content, isVisible }) {
  const tooltipRef = useRef()
  const triggerRef = useRef()

  useLayoutEffect(() =&gt; {
    if (isVisible &amp;&amp; tooltipRef.current &amp;&amp; triggerRef.current) {
      const triggerRect = triggerRef.current.getBoundingClientRect()
      const tooltipRect = tooltipRef.current.getBoundingClientRect()
      
      // 计算最佳位置
      let top = triggerRect.top - tooltipRect.height - 8
      let left = triggerRect.left + (triggerRect.width - tooltipRect.width) / 2

      // 边界检查
      if (top &lt; 0) {
        top = triggerRect.bottom + 8
      }
      
      if (left &lt; 0) {
        left = 8
      } else if (left + tooltipRect.width &gt; window.innerWidth) {
        left = window.innerWidth - tooltipRect.width - 8
      }

      tooltipRef.current.style.top = `${top}px`
      tooltipRef.current.style.left = `${left}px`
    }
  }, [isVisible])

  return (
    &lt;div className=&quot;tooltip-container&quot;&gt;
      &lt;div ref={triggerRef}&gt;
        {children}
      &lt;/div&gt;
      
      {isVisible &amp;&amp; (
        &lt;div 
          ref={tooltipRef}
          className=&quot;tooltip&quot;
          style={{ position: &#39;fixed&#39;, visibility: &#39;hidden&#39; }}
        &gt;
          {content}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  )
}

// 测量元素尺寸
function ResizableBox({ children }) {
  const boxRef = useRef()
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 })

  useLayoutEffect(() =&gt; {
    const measureBox = () =&gt; {
      if (boxRef.current) {
        const { offsetWidth, offsetHeight } = boxRef.current
        setDimensions({ width: offsetWidth, height: offsetHeight })
      }
    }

    measureBox()

    // 监听尺寸变化
    const resizeObserver = new ResizeObserver(measureBox)
    if (boxRef.current) {
      resizeObserver.observe(boxRef.current)
    }

    return () =&gt; resizeObserver.disconnect()
  }, [])

  return (
    &lt;div ref={boxRef} className=&quot;resizable-box&quot;&gt;
      &lt;div className=&quot;dimensions-display&quot;&gt;
        {dimensions.width} × {dimensions.height}
      &lt;/div&gt;
      {children}
    &lt;/div&gt;
  )
}

// 滚动位置同步
function ScrollSyncPane({ children, scrollTop, onScroll }) {
  const paneRef = useRef()

  useLayoutEffect(() =&gt; {
    if (paneRef.current &amp;&amp; paneRef.current.scrollTop !== scrollTop) {
      paneRef.current.scrollTop = scrollTop
    }
  }, [scrollTop])

  const handleScroll = (e) =&gt; {
    onScroll(e.target.scrollTop)
  }

  return (
    &lt;div 
      ref={paneRef}
      className=&quot;scroll-pane&quot;
      onScroll={handleScroll}
    &gt;
      {children}
    &lt;/div&gt;
  )
}

function ScrollSyncExample() {
  const [scrollTop, setScrollTop] = useState(0)

  return (
    &lt;div style={{ display: &#39;flex&#39; }}&gt;
      &lt;ScrollSyncPane scrollTop={scrollTop} onScroll={setScrollTop}&gt;
        &lt;div style={{ height: &#39;1000px&#39; }}&gt;
          Left Pane Content
        &lt;/div&gt;
      &lt;/ScrollSyncPane&gt;
      
      &lt;ScrollSyncPane scrollTop={scrollTop} onScroll={setScrollTop}&gt;
        &lt;div style={{ height: &#39;1000px&#39; }}&gt;
          Right Pane Content
        &lt;/div&gt;
      &lt;/ScrollSyncPane&gt;
    &lt;/div&gt;
  )
}

// 动画同步
function AnimatedHeight({ isExpanded, children }) {
  const contentRef = useRef()
  const [height, setHeight] = useState(0)

  useLayoutEffect(() =&gt; {
    if (contentRef.current) {
      const contentHeight = contentRef.current.scrollHeight
      setHeight(isExpanded ? contentHeight : 0)
    }
  }, [isExpanded, children])

  return (
    &lt;div 
      style={{ 
        height: height,
        overflow: &#39;hidden&#39;,
        transition: &#39;height 0.3s ease&#39;
      }}
    &gt;
      &lt;div ref={contentRef}&gt;
        {children}
      &lt;/div&gt;
    &lt;/div&gt;
  )
}

// DOM操作避免闪烁
function ThemeToggle() {
  const [theme, setTheme] = useState(&#39;light&#39;)

  useLayoutEffect(() =&gt; {
    // 在绘制前应用主题，避免闪烁
    document.documentElement.setAttribute(&#39;data-theme&#39;, theme)
    
    // 也可以直接修改样式
    document.body.className = `theme-${theme}`
  }, [theme])

  return (
    &lt;button onClick={() =&gt; setTheme(theme === &#39;light&#39; ? &#39;dark&#39; : &#39;light&#39;)}&gt;
      Switch to {theme === &#39;light&#39; ? &#39;dark&#39; : &#39;light&#39;} theme
    &lt;/button&gt;
  )
}

// 自定义Hook - 测量元素
function useElementSize() {
  const ref = useRef()
  const [size, setSize] = useState({ width: 0, height: 0 })

  useLayoutEffect(() =&gt; {
    const measureElement = () =&gt; {
      if (ref.current) {
        const { offsetWidth, offsetHeight } = ref.current
        setSize({ width: offsetWidth, height: offsetHeight })
      }
    }

    measureElement()

    const resizeObserver = new ResizeObserver(measureElement)
    if (ref.current) {
      resizeObserver.observe(ref.current)
    }

    return () =&gt; resizeObserver.disconnect()
  }, [])

  return [ref, size]
}

function ComponentWithSize() {
  const [ref, size] = useElementSize()

  return (
    &lt;div ref={ref} style={{ resize: &#39;both&#39;, overflow: &#39;auto&#39;, border: &#39;1px solid&#39; }}&gt;
      &lt;p&gt;Width: {size.width}px&lt;/p&gt;
      &lt;p&gt;Height: {size.height}px&lt;/p&gt;
      &lt;p&gt;调整我的大小&lt;/p&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<h3>注意事项</h3>
<ol>
<li><strong>性能影响</strong> - 同步执行，可能阻塞浏览器绘制</li>
<li><strong>使用时机</strong> - 只在真正需要同步DOM操作时使用</li>
<li><strong>服务端渲染</strong> - 在SSR中可能导致警告</li>
<li><strong>与useEffect区别</strong> - useLayoutEffect在DOM变更后、绘制前执行</li>
</ol>
<hr>
<h2>useDebugValue</h2>
<p>在React开发者工具中显示自定义Hook的标签。</p>
<h3>语法</h3>
<pre><code class="language-typescript">useDebugValue&lt;T&gt;(
  value: T,
  format?: (value: T) =&gt; any
): void
</code></pre>
<h3>参数</h3>
<ul>
<li><strong>value</strong>: <code>T</code> - 要显示的调试值</li>
<li><strong>format</strong>: <code>(value: T) =&gt; any</code> (可选) - 格式化函数，只在DevTools打开时调用</li>
</ul>
<h3>返回值</h3>
<p>无返回值</p>
<h3>使用规则</h3>
<ol>
<li>只能在自定义Hook中调用</li>
<li>不要在普通组件中使用</li>
<li>只在React DevTools中可见</li>
</ol>
<h3>使用场景</h3>
<ul>
<li>调试自定义Hook</li>
<li>显示Hook的内部状态</li>
<li>提供有用的调试信息</li>
<li>开发组件库时提供更好的开发体验</li>
</ul>
<h3>代码示例</h3>
<pre><code class="language-jsx">// 基础用法
function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue)

  // 在DevTools中显示当前计数
  useDebugValue(count)

  const increment = useCallback(() =&gt; setCount(c =&gt; c + 1), [])
  const decrement = useCallback(() =&gt; setCount(c =&gt; c - 1), [])
  const reset = useCallback(() =&gt; setCount(initialValue), [initialValue])

  return { count, increment, decrement, reset }
}

// 格式化显示
function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue)

  // 使用格式化函数提供更友好的显示
  useDebugValue(value, value =&gt; value ? &#39;ON&#39; : &#39;OFF&#39;)

  const toggle = useCallback(() =&gt; setValue(v =&gt; !v), [])
  const setTrue = useCallback(() =&gt; setValue(true), [])
  const setFalse = useCallback(() =&gt; setValue(false), [])

  return { value, toggle, setTrue, setFalse }
}

// 复杂状态的调试
function useForm(initialValues = {}) {
  const [values, setValues] = useState(initialValues)
  const [errors, setErrors] = useState({})
  const [touched, setTouched] = useState({})

  // 显示表单状态概览
  useDebugValue(
    { values, errors, touched },
    ({ values, errors, touched }) =&gt; {
      const fieldCount = Object.keys(values).length
      const errorCount = Object.keys(errors).length
      const touchedCount = Object.keys(touched).length
      
      return `${fieldCount} fields, ${errorCount} errors, ${touchedCount} touched`
    }
  )

  const setValue = useCallback((name, value) =&gt; {
    setValues(prev =&gt; ({ ...prev, [name]: value }))
  }, [])

  const setError = useCallback((name, error) =&gt; {
    setErrors(prev =&gt; ({ ...prev, [name]: error }))
  }, [])

  const setTouched = useCallback((name) =&gt; {
    setTouched(prev =&gt; ({ ...prev, [name]: true }))
  }, [])

  return {
    values,
    errors,
    touched,
    setValue,
    setError,
    setTouched
  }
}

// API状态调试
function useApi(url) {
  const [data, setData] = useState(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)

  // 显示API状态
  useDebugValue(
    { url, loading, error: !!error },
    ({ url, loading, error }) =&gt; {
      if (loading) return `Loading: ${url}`
      if (error) return `Error: ${url}`
      return `Success: ${url}`
    }
  )

  const fetchData = useCallback(async () =&gt; {
    setLoading(true)
    setError(null)
    
    try {
      const response = await fetch(url)
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`)
      }
      const result = await response.json()
      setData(result)
    } catch (err) {
      setError(err.message)
    } finally {
      setLoading(false)
    }
  }, [url])

  useEffect(() =&gt; {
    fetchData()
  }, [fetchData])

  return { data, loading, error, refetch: fetchData }
}

// 本地存储Hook调试
function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() =&gt; {
    try {
      const item = window.localStorage.getItem(key)
      return item ? JSON.parse(item) : initialValue
    } catch (error) {
      console.log(error)
      return initialValue
    }
  })

  // 显示存储键和值的概述
  useDebugValue(
    { key, value: storedValue },
    ({ key, value }) =&gt; `${key}: ${JSON.stringify(value).slice(0, 50)}...`
  )

  const setValue = useCallback((value) =&gt; {
    try {
      setStoredValue(value)
      window.localStorage.setItem(key, JSON.stringify(value))
    } catch (error) {
      console.log(error)
    }
  }, [key])

  return [storedValue, setValue]
}

// 定时器Hook调试
function useInterval(callback, delay) {
  const savedCallback = useRef()
  const [isRunning, setIsRunning] = useState(delay !== null)

  // 显示定时器状态
  useDebugValue(
    { delay, isRunning },
    ({ delay, isRunning }) =&gt; 
      isRunning ? `Running every ${delay}ms` : &#39;Stopped&#39;
  )

  useEffect(() =&gt; {
    savedCallback.current = callback
  }, [callback])

  useEffect(() =&gt; {
    function tick() {
      savedCallback.current()
    }

    if (delay !== null) {
      const id = setInterval(tick, delay)
      return () =&gt; clearInterval(id)
    }
  }, [delay])

  return { isRunning, start: () =&gt; setIsRunning(true), stop: () =&gt; setIsRunning(false) }
}

// 网络状态Hook调试
function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(navigator.onLine)

  // 简单的在线状态显示
  useDebugValue(isOnline ? &#39;Online&#39; : &#39;Offline&#39;)

  useEffect(() =&gt; {
    const handleOnline = () =&gt; setIsOnline(true)
    const handleOffline = () =&gt; setIsOnline(false)

    window.addEventListener(&#39;online&#39;, handleOnline)
    window.addEventListener(&#39;offline&#39;, handleOffline)

    return () =&gt; {
      window.removeEventListener(&#39;online&#39;, handleOnline)
      window.removeEventListener(&#39;offline&#39;, handleOffline)
    }
  }, [])

  return isOnline
}

// 使用示例
function App() {
  const { count, increment } = useCounter(0)
  const { value: isVisible, toggle } = useToggle(false)
  const { data, loading } = useApi(&#39;/api/users&#39;)
  const [settings, setSettings] = useLocalStorage(&#39;settings&#39;, {})
  const isOnline = useOnlineStatus()

  return (
    &lt;div&gt;
      &lt;div&gt;Count: {count}&lt;/div&gt;
      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;
      
      &lt;div&gt;Visible: {isVisible ? &#39;Yes&#39; : &#39;No&#39;}&lt;/div&gt;
      &lt;button onClick={toggle}&gt;Toggle&lt;/button&gt;
      
      &lt;div&gt;Online: {isOnline ? &#39;Yes&#39; : &#39;No&#39;}&lt;/div&gt;
      
      {loading ? &lt;div&gt;Loading...&lt;/div&gt; : &lt;div&gt;Data loaded&lt;/div&gt;}
    &lt;/div&gt;
  )
}
</code></pre>
<h3>注意事项</h3>
<ol>
<li><strong>仅开发模式</strong> - 只在开发环境和React DevTools中显示</li>
<li><strong>格式化性能</strong> - 格式化函数只在DevTools打开时调用</li>
<li><strong>不要过度使用</strong> - 只在真正需要调试信息时使用</li>
<li><strong>自定义Hook专用</strong> - 不要在普通组件中使用</li>
</ol>
<hr>
<h2>useId</h2>
<p>生成稳定的唯一ID，用于可访问性属性。</p>
<h3>语法</h3>
<pre><code class="language-typescript">const id = useId(): string
</code></pre>
<h3>参数</h3>
<p>无参数</p>
<h3>返回值</h3>
<ul>
<li><strong>id</strong>: <code>string</code> - 唯一的字符串ID</li>
</ul>
<h3>使用规则</h3>
<ol>
<li>只能在函数组件或自定义Hook中调用</li>
<li>必须在组件的顶层调用</li>
<li>生成的ID在客户端和服务端保持一致</li>
</ol>
<h3>使用场景</h3>
<ul>
<li>表单标签与输入框的关联</li>
<li>ARIA属性的ID引用</li>
<li>避免多个组件实例的ID冲突</li>
<li>服务端渲染的ID一致性</li>
</ul>
<h3>代码示例</h3>
<pre><code class="language-jsx">// 基础用法 - 表单标签关联
function FormField({ label, type = &#39;text&#39;, ...props }) {
  const id = useId()

  return (
    &lt;div&gt;
      &lt;label htmlFor={id}&gt;{label}&lt;/label&gt;
      &lt;input id={id} type={type} {...props} /&gt;
    &lt;/div&gt;
  )
}

// 复杂表单
function ContactForm() {
  return (
    &lt;form&gt;
      &lt;FormField label=&quot;姓名&quot; name=&quot;name&quot; required /&gt;
      &lt;FormField label=&quot;邮箱&quot; type=&quot;email&quot; name=&quot;email&quot; required /&gt;
      &lt;FormField label=&quot;电话&quot; type=&quot;tel&quot; name=&quot;phone&quot; /&gt;
    &lt;/form&gt;
  )
}

// ARIA属性关联
function ExpandableSection({ title, children }) {
  const titleId = useId()
  const contentId = useId()
  const [isExpanded, setIsExpanded] = useState(false)

  return (
    &lt;div&gt;
      &lt;button
        id={titleId}
        aria-expanded={isExpanded}
        aria-controls={contentId}
        onClick={() =&gt; setIsExpanded(!isExpanded)}
      &gt;
        {title}
      &lt;/button&gt;
      
      &lt;div
        id={contentId}
        role=&quot;region&quot;
        aria-labelledby={titleId}
        hidden={!isExpanded}
      &gt;
        {children}
      &lt;/div&gt;
    &lt;/div&gt;
  )
}

// 多个ID的场景
function SearchableSelect({ options, placeholder }) {
  const baseId = useId()
  const inputId = `${baseId}-input`
  const listboxId = `${baseId}-listbox`
  const optionIdPrefix = `${baseId}-option`
  
  const [query, setQuery] = useState(&#39;&#39;)
  const [isOpen, setIsOpen] = useState(false)
  const [selectedIndex, setSelectedIndex] = useState(-1)

  const filteredOptions = options.filter(option =&gt;
    option.label.toLowerCase().includes(query.toLowerCase())
  )

  return (
    &lt;div className=&quot;search-select&quot;&gt;
      &lt;input
        id={inputId}
        type=&quot;text&quot;
        value={query}
        onChange={(e) =&gt; setQuery(e.target.value)}
        onFocus={() =&gt; setIsOpen(true)}
        placeholder={placeholder}
        role=&quot;combobox&quot;
        aria-expanded={isOpen}
        aria-controls={listboxId}
        aria-activedescendant={
          selectedIndex &gt;= 0 ? `${optionIdPrefix}-${selectedIndex}` : undefined
        }
      /&gt;
      
      {isOpen &amp;&amp; (
        &lt;ul
          id={listboxId}
          role=&quot;listbox&quot;
          aria-labelledby={inputId}
        &gt;
          {filteredOptions.map((option, index) =&gt; (
            &lt;li
              key={option.value}
              id={`${optionIdPrefix}-${index}`}
              role=&quot;option&quot;
              aria-selected={index === selectedIndex}
              onClick={() =&gt; {
                setQuery(option.label)
                setIsOpen(false)
              }}
            &gt;
              {option.label}
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
      )}
    &lt;/div&gt;
  )
}

// 自定义Hook中使用
function useFormField(name, validation) {
  const id = useId()
  const errorId = `${id}-error`
  const descriptionId = `${id}-description`
  
  const [value, setValue] = useState(&#39;&#39;)
  const [error, setError] = useState(&#39;&#39;)
  const [touched, setTouched] = useState(false)

  const validate = useCallback(() =&gt; {
    if (validation) {
      const result = validation(value)
      setError(result || &#39;&#39;)
      return !result
    }
    return true
  }, [value, validation])

  return {
    field: {
      id,
      name,
      value,
      onChange: (e) =&gt; setValue(e.target.value),
      onBlur: () =&gt; {
        setTouched(true)
        validate()
      },
      &#39;aria-describedby&#39;: error ? errorId : undefined,
      &#39;aria-invalid&#39;: touched &amp;&amp; !!error
    },
    error: {
      id: errorId,
      message: error,
      show: touched &amp;&amp; !!error
    },
    description: {
      id: descriptionId
    },
    isValid: !error,
    validate
  }
}

function AdvancedForm() {
  const nameField = useFormField(&#39;name&#39;, (value) =&gt; 
    value.length &lt; 2 ? &#39;姓名至少需要2个字符&#39; : null
  )
  
  const emailField = useFormField(&#39;email&#39;, (value) =&gt; 
    !/\S+@\S+\.\S+/.test(value) ? &#39;请输入有效的邮箱地址&#39; : null
  )

  const handleSubmit = (e) =&gt; {
    e.preventDefault()
    
    const isNameValid = nameField.validate()
    const isEmailValid = emailField.validate()
    
    if (isNameValid &amp;&amp; isEmailValid) {
      console.log(&#39;Form submitted&#39;, {
        name: nameField.field.value,
        email: emailField.field.value
      })
    }
  }

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;label htmlFor={nameField.field.id}&gt;姓名&lt;/label&gt;
        &lt;input {...nameField.field} type=&quot;text&quot; /&gt;
        {nameField.error.show &amp;&amp; (
          &lt;div id={nameField.error.id} role=&quot;alert&quot;&gt;
            {nameField.error.message}
          &lt;/div&gt;
        )}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label htmlFor={emailField.field.id}&gt;邮箱&lt;/label&gt;
        &lt;input {...emailField.field} type=&quot;email&quot; /&gt;
        {emailField.error.show &amp;&amp; (
          &lt;div id={emailField.error.id} role=&quot;alert&quot;&gt;
            {emailField.error.message}
          &lt;/div&gt;
        )}
      &lt;/div&gt;

      &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;
    &lt;/form&gt;
  )
}

// 组件列表中的唯一ID
function TodoList({ todos }) {
  return (
    &lt;ul&gt;
      {todos.map((todo) =&gt; (
        &lt;TodoItem key={todo.id} todo={todo} /&gt;
      ))}
    &lt;/ul&gt;
  )
}

function TodoItem({ todo }) {
  const checkboxId = useId()
  const descriptionId = useId()
  
  return (
    &lt;li&gt;
      &lt;input
        id={checkboxId}
        type=&quot;checkbox&quot;
        checked={todo.completed}
        aria-describedby={descriptionId}
      /&gt;
      &lt;label htmlFor={checkboxId}&gt;
        {todo.title}
      &lt;/label&gt;
      {todo.description &amp;&amp; (
        &lt;p id={descriptionId} className=&quot;todo-description&quot;&gt;
          {todo.description}
        &lt;/p&gt;
      )}
    &lt;/li&gt;
  )
}
</code></pre>
<h3>注意事项</h3>
<ol>
<li><strong>服务端渲染</strong> - 确保客户端和服务端生成相同的ID</li>
<li><strong>不要用作key</strong> - useId不适合作为列表的key属性</li>
<li><strong>前缀使用</strong> - 可以添加前缀创建相关的多个ID</li>
<li><strong>避免条件调用</strong> - 不要在条件语句中调用useId</li>
</ol>
<hr>
<h2>useTransition</h2>
<p>标记状态更新为过渡状态，允许其他更新打断它们。</p>
<h3>语法</h3>
<pre><code class="language-typescript">const [isPending, startTransition] = useTransition(): [boolean, (callback: () =&gt; void) =&gt; void]
</code></pre>
<h3>参数</h3>
<p>无参数</p>
<h3>返回值</h3>
<p>返回包含两个元素的数组：</p>
<ul>
<li><strong>isPending</strong>: <code>boolean</code> - 表示是否有待处理的过渡</li>
<li><strong>startTransition</strong>: <code>(callback: () =&gt; void) =&gt; void</code> - 启动过渡的函数</li>
</ul>
<h3>使用规则</h3>
<ol>
<li>只能在函数组件或自定义Hook中调用</li>
<li>必须在组件的顶层调用</li>
<li>过渡更新可以被紧急更新打断</li>
</ol>
<h3>使用场景</h3>
<ul>
<li>大列表的筛选和排序</li>
<li>复杂计算结果的展示</li>
<li>路由切换的优化</li>
<li>提升用户交互的响应性</li>
</ul>
<h3>代码示例</h3>
<pre><code class="language-jsx">// 大列表搜索优化
function ProductList({ products }) {
  const [query, setQuery] = useState(&#39;&#39;)
  const [filteredProducts, setFilteredProducts] = useState(products)
  const [isPending, startTransition] = useTransition()

  const handleSearch = (newQuery) =&gt; {
    // 立即更新输入框（紧急更新）
    setQuery(newQuery)
    
    // 延迟更新搜索结果（过渡更新）
    startTransition(() =&gt; {
      const filtered = products.filter(product =&gt;
        product.name.toLowerCase().includes(newQuery.toLowerCase()) ||
        product.description.toLowerCase().includes(newQuery.toLowerCase())
      )
      setFilteredProducts(filtered)
    })
  }

  return (
    &lt;div&gt;
      &lt;input
        type=&quot;text&quot;
        value={query}
        onChange={(e) =&gt; handleSearch(e.target.value)}
        placeholder=&quot;搜索产品...&quot;
      /&gt;
      
      {isPending &amp;&amp; &lt;div&gt;搜索中...&lt;/div&gt;}
      
      &lt;div className={isPending ? &#39;opacity-50&#39; : &#39;&#39;}&gt;
        {filteredProducts.map(product =&gt; (
          &lt;ProductCard key={product.id} product={product} /&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
  )
}

// 标签页切换优化
function TabContainer() {
  const [activeTab, setActiveTab] = useState(&#39;posts&#39;)
  const [isPending, startTransition] = useTransition()

  const handleTabChange = (tab) =&gt; {
    startTransition(() =&gt; {
      setActiveTab(tab)
    })
  }

  return (
    &lt;div&gt;
      &lt;div className=&quot;tab-buttons&quot;&gt;
        &lt;button
          onClick={() =&gt; handleTabChange(&#39;posts&#39;)}
          className={activeTab === &#39;posts&#39; ? &#39;active&#39; : &#39;&#39;}
        &gt;
          文章 {isPending &amp;&amp; activeTab === &#39;posts&#39; &amp;&amp; &#39;...&#39;}
        &lt;/button&gt;
        
        &lt;button
          onClick={() =&gt; handleTabChange(&#39;contact&#39;)}
          className={activeTab === &#39;contact&#39; ? &#39;active&#39; : &#39;&#39;}
        &gt;
          联系方式 {isPending &amp;&amp; activeTab === &#39;contact&#39; &amp;&amp; &#39;...&#39;}
        &lt;/button&gt;
        
        &lt;button
          onClick={() =&gt; handleTabChange(&#39;about&#39;)}
          className={activeTab === &#39;about&#39; ? &#39;active&#39; : &#39;&#39;}
        &gt;
          关于我们 {isPending &amp;&amp; activeTab === &#39;about&#39; &amp;&amp; &#39;...&#39;}
        &lt;/button&gt;
      &lt;/div&gt;

      &lt;div className={`tab-content ${isPending ? &#39;loading&#39; : &#39;&#39;}`}&gt;
        {activeTab === &#39;posts&#39; &amp;&amp; &lt;PostsTab /&gt;}
        {activeTab === &#39;contact&#39; &amp;&amp; &lt;ContactTab /&gt;}
        {activeTab === &#39;about&#39; &amp;&amp; &lt;AboutTab /&gt;}
      &lt;/div&gt;
    &lt;/div&gt;
  )
}

// 复杂计算的优化
function DataVisualization({ rawData }) {
  const [chartType, setChartType] = useState(&#39;bar&#39;)
  const [processedData, setProcessedData] = useState(null)
  const [isPending, startTransition] = useTransition()

  const processData = (type, data) =&gt; {
    // 模拟复杂的数据处理
    const processed = data.map(item =&gt; ({
      ...item,
      processed: true,
      chartType: type,
      // 复杂计算...
      value: item.value * (type === &#39;pie&#39; ? 1.2 : 1)
    }))
    
    return processed
  }

  const handleChartTypeChange = (type) =&gt; {
    setChartType(type)
    
    startTransition(() =&gt; {
      const processed = processData(type, rawData)
      setProcessedData(processed)
    })
  }

  return (
    &lt;div&gt;
      &lt;div className=&quot;chart-controls&quot;&gt;
        &lt;button onClick={() =&gt; handleChartTypeChange(&#39;bar&#39;)}&gt;
          柱状图
        &lt;/button&gt;
        &lt;button onClick={() =&gt; handleChartTypeChange(&#39;line&#39;)}&gt;
          折线图
        &lt;/button&gt;
        &lt;button onClick={() =&gt; handleChartTypeChange(&#39;pie&#39;)}&gt;
          饼图
        &lt;/button&gt;
      &lt;/div&gt;

      {isPending ? (
        &lt;div&gt;数据处理中...&lt;/div&gt;
      ) : (
        &lt;Chart type={chartType} data={processedData} /&gt;
      )}
    &lt;/div&gt;
  )
}

// 表单验证优化
function AdvancedSignupForm() {
  const [formData, setFormData] = useState({
    username: &#39;&#39;,
    email: &#39;&#39;,
    password: &#39;&#39;
  })
  const [validationResults, setValidationResults] = useState({})
  const [isPending, startTransition] = useTransition()

  const validateField = async (name, value) =&gt; {
    // 模拟异步验证
    await new Promise(resolve =&gt; setTimeout(resolve, 300))
    
    const validations = {
      username: (val) =&gt; val.length &lt; 3 ? &#39;用户名至少3个字符&#39; : null,
      email: (val) =&gt; !/\S+@\S+\.\S+/.test(val) ? &#39;邮箱格式不正确&#39; : null,
      password: (val) =&gt; val.length &lt; 6 ? &#39;密码至少6个字符&#39; : null
    }

    return validations[name] ? validations[name](value) : null
  }

  const handleFieldChange = (name, value) =&gt; {
    // 立即更新表单数据
    setFormData(prev =&gt; ({ ...prev, [name]: value }))
    
    // 延迟验证（过渡更新）
    startTransition(async () =&gt; {
      const error = await validateField(name, value)
      setValidationResults(prev =&gt; ({
        ...prev,
        [name]: error
      }))
    })
  }

  return (
    &lt;form&gt;
      &lt;div&gt;
        &lt;input
          type=&quot;text&quot;
          value={formData.username}
          onChange={(e) =&gt; handleFieldChange(&#39;username&#39;, e.target.value)}
          placeholder=&quot;用户名&quot;
        /&gt;
        {isPending &amp;&amp; &lt;span&gt;验证中...&lt;/span&gt;}
        {validationResults.username &amp;&amp; (
          &lt;div className=&quot;error&quot;&gt;{validationResults.username}&lt;/div&gt;
        )}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;input
          type=&quot;email&quot;
          value={formData.email}
          onChange={(e) =&gt; handleFieldChange(&#39;email&#39;, e.target.value)}
          placeholder=&quot;邮箱&quot;
        /&gt;
        {validationResults.email &amp;&amp; (
          &lt;div className=&quot;error&quot;&gt;{validationResults.email}&lt;/div&gt;
        )}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;input
          type=&quot;password&quot;
          value={formData.password}
          onChange={(e) =&gt; handleFieldChange(&#39;password&#39;, e.target.value)}
          placeholder=&quot;密码&quot;
        /&gt;
        {validationResults.password &amp;&amp; (
          &lt;div className=&quot;error&quot;&gt;{validationResults.password}&lt;/div&gt;
        )}
      &lt;/div&gt;

      &lt;button type=&quot;submit&quot;&gt;注册&lt;/button&gt;
    &lt;/form&gt;
  )
}

// 自定义Hook封装
function useFilteredList(items, filterFn) {
  const [filter, setFilter] = useState(&#39;&#39;)
  const [filteredItems, setFilteredItems] = useState(items)
  const [isPending, startTransition] = useTransition()

  const updateFilter = (newFilter) =&gt; {
    setFilter(newFilter)
    
    startTransition(() =&gt; {
      const filtered = newFilter 
        ? items.filter(item =&gt; filterFn(item, newFilter))
        : items
      setFilteredItems(filtered)
    })
  }

  return {
    filter,
    filteredItems,
    updateFilter,
    isPending
  }
}

function UserDirectory({ users }) {
  const { filter, filteredItems, updateFilter, isPending } = useFilteredList(
    users,
    (user, query) =&gt; 
      user.name.toLowerCase().includes(query.toLowerCase()) ||
      user.department.toLowerCase().includes(query.toLowerCase())
  )

  return (
    &lt;div&gt;
      &lt;input
        type=&quot;text&quot;
        value={filter}
        onChange={(e) =&gt; updateFilter(e.target.value)}
        placeholder=&quot;搜索用户...&quot;
      /&gt;
      
      &lt;div className={isPending ? &#39;searching&#39; : &#39;&#39;}&gt;
        {isPending &amp;&amp; &lt;div&gt;搜索中...&lt;/div&gt;}
        {filteredItems.map(user =&gt; (
          &lt;UserCard key={user.id} user={user} /&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<h3>注意事项</h3>
<ol>
<li><strong>优先级管理</strong> - 过渡更新优先级低，可被紧急更新打断</li>
<li><strong>用户体验</strong> - 使用isPending提供视觉反馈</li>
<li><strong>性能考虑</strong> - 不要在每个状态更新中都使用过渡</li>
<li><strong>异步操作</strong> - 过渡不会等待异步操作完成</li>
</ol>
<hr>
<h2>useDeferredValue</h2>
<p>延迟更新值，当有更紧急的更新时推迟低优先级的值更新。</p>
<h3>语法</h3>
<pre><code class="language-typescript">const deferredValue = useDeferredValue&lt;T&gt;(value: T): T
</code></pre>
<h3>参数</h3>
<ul>
<li><strong>value</strong>: <code>T</code> - 要延迟的值</li>
</ul>
<h3>返回值</h3>
<ul>
<li><strong>deferredValue</strong>: <code>T</code> - 延迟的值</li>
</ul>
<h3>使用规则</h3>
<ol>
<li>只能在函数组件或自定义Hook中调用</li>
<li>必须在组件的顶层调用</li>
<li>延迟值在紧急更新期间保持旧值</li>
</ol>
<h3>使用场景</h3>
<ul>
<li>搜索结果的延迟渲染</li>
<li>昂贵的列表过滤</li>
<li>图表数据的延迟更新</li>
<li>优化用户输入响应性</li>
</ul>
<h3>代码示例</h3>
<pre><code class="language-jsx">// 搜索结果延迟渲染
function SearchResults({ query }) {
  const deferredQuery = useDeferredValue(query)
  const [results, setResults] = useState([])
  const [isLoading, setIsLoading] = useState(false)

  useEffect(() =&gt; {
    if (deferredQuery) {
      setIsLoading(true)
      
      // 模拟API调用
      const searchAPI = async () =&gt; {
        const response = await fetch(`/api/search?q=${deferredQuery}`)
        const data = await response.json()
        setResults(data)
        setIsLoading(false)
      }

      searchAPI()
    } else {
      setResults([])
      setIsLoading(false)
    }
  }, [deferredQuery])

  // 当查询值和延迟值不同时，显示正在更新的状态
  const isStale = query !== deferredQuery

  return (
    &lt;div className={isStale ? &#39;opacity-60&#39; : &#39;&#39;}&gt;
      {isLoading &amp;&amp; &lt;div&gt;搜索中...&lt;/div&gt;}
      {isStale &amp;&amp; &lt;div&gt;更新中...&lt;/div&gt;}
      
      &lt;ul&gt;
        {results.map(result =&gt; (
          &lt;li key={result.id}&gt;{result.title}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  )
}

function SearchApp() {
  const [query, setQuery] = useState(&#39;&#39;)

  return (
    &lt;div&gt;
      &lt;input
        type=&quot;text&quot;
        value={query}
        onChange={(e) =&gt; setQuery(e.target.value)}
        placeholder=&quot;搜索...&quot;
      /&gt;
      &lt;SearchResults query={query} /&gt;
    &lt;/div&gt;
  )
}

// 大列表过滤优化
function ProductCatalog({ products }) {
  const [filter, setFilter] = useState(&#39;&#39;)
  const deferredFilter = useDeferredValue(filter)

  const filteredProducts = useMemo(() =&gt; {
    if (!deferredFilter) return products
    
    return products.filter(product =&gt;
      product.name.toLowerCase().includes(deferredFilter.toLowerCase()) ||
      product.category.toLowerCase().includes(deferredFilter.toLowerCase())
    )
  }, [products, deferredFilter])

  const isFiltering = filter !== deferredFilter

  return (
    &lt;div&gt;
      &lt;input
        type=&quot;text&quot;
        value={filter}
        onChange={(e) =&gt; setFilter(e.target.value)}
        placeholder=&quot;过滤产品...&quot;
      /&gt;
      
      &lt;div className={isFiltering ? &#39;filtering&#39; : &#39;&#39;}&gt;
        {isFiltering &amp;&amp; &lt;div&gt;过滤中...&lt;/div&gt;}
        
        &lt;div className=&quot;product-grid&quot;&gt;
          {filteredProducts.map(product =&gt; (
            &lt;ProductCard key={product.id} product={product} /&gt;
          ))}
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  )
}

// 图表数据延迟更新
function InteractiveChart({ data, chartType, options }) {
  const deferredData = useDeferredValue(data)
  const deferredOptions = useDeferredValue(options)

  const processedData = useMemo(() =&gt; {
    // 复杂的数据处理
    console.log(&#39;Processing chart data...&#39;)
    return processChartData(deferredData, chartType, deferredOptions)
  }, [deferredData, chartType, deferredOptions])

  const isUpdating = data !== deferredData || options !== deferredOptions

  return (
    &lt;div className=&quot;chart-container&quot;&gt;
      {isUpdating &amp;&amp; (
        &lt;div className=&quot;update-indicator&quot;&gt;图表更新中...&lt;/div&gt;
      )}
      
      &lt;Chart
        data={processedData}
        type={chartType}
        options={deferredOptions}
        className={isUpdating ? &#39;updating&#39; : &#39;&#39;}
      /&gt;
    &lt;/div&gt;
  )
}

// 复杂表单验证
function FormWithValidation() {
  const [formData, setFormData] = useState({
    name: &#39;&#39;,
    email: &#39;&#39;,
    message: &#39;&#39;
  })
  
  const deferredFormData = useDeferredValue(formData)
  const [validationErrors, setValidationErrors] = useState({})

  const validateForm = useMemo(() =&gt; {
    const errors = {}
    
    if (deferredFormData.name.length &lt; 2) {
      errors.name = &#39;姓名至少需要2个字符&#39;
    }
    
    if (!/\S+@\S+\.\S+/.test(deferredFormData.email)) {
      errors.email = &#39;邮箱格式不正确&#39;
    }
    
    if (deferredFormData.message.length &lt; 10) {
      errors.message = &#39;消息至少需要10个字符&#39;
    }

    return errors
  }, [deferredFormData])

  useEffect(() =&gt; {
    setValidationErrors(validateForm)
  }, [validateForm])

  const isValidating = formData !== deferredFormData

  const updateField = (field, value) =&gt; {
    setFormData(prev =&gt; ({ ...prev, [field]: value }))
  }

  return (
    &lt;form&gt;
      &lt;div&gt;
        &lt;input
          type=&quot;text&quot;
          value={formData.name}
          onChange={(e) =&gt; updateField(&#39;name&#39;, e.target.value)}
          placeholder=&quot;姓名&quot;
        /&gt;
        {isValidating &amp;&amp; &lt;span&gt;验证中...&lt;/span&gt;}
        {validationErrors.name &amp;&amp; (
          &lt;div className=&quot;error&quot;&gt;{validationErrors.name}&lt;/div&gt;
        )}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;input
          type=&quot;email&quot;
          value={formData.email}
          onChange={(e) =&gt; updateField(&#39;email&#39;, e.target.value)}
          placeholder=&quot;邮箱&quot;
        /&gt;
        {validationErrors.email &amp;&amp; (
          &lt;div className=&quot;error&quot;&gt;{validationErrors.email}&lt;/div&gt;
        )}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;textarea
          value={formData.message}
          onChange={(e) =&gt; updateField(&#39;message&#39;, e.target.value)}
          placeholder=&quot;消息&quot;
        /&gt;
        {validationErrors.message &amp;&amp; (
          &lt;div className=&quot;error&quot;&gt;{validationErrors.message}&lt;/div&gt;
        )}
      &lt;/div&gt;

      &lt;button type=&quot;submit&quot; disabled={Object.keys(validationErrors).length &gt; 0}&gt;
        提交
      &lt;/button&gt;
    &lt;/form&gt;
  )
}

// 自定义Hook - 延迟搜索
function useDeferredSearch(searchTerm, searchFunction) {
  const deferredTerm = useDeferredValue(searchTerm)
  const [results, setResults] = useState([])
  const [isSearching, setIsSearching] = useState(false)

  useEffect(() =&gt; {
    if (deferredTerm) {
      setIsSearching(true)
      
      const performSearch = async () =&gt; {
        try {
          const searchResults = await searchFunction(deferredTerm)
          setResults(searchResults)
        } catch (error) {
          console.error(&#39;Search failed:&#39;, error)
          setResults([])
        } finally {
          setIsSearching(false)
        }
      }

      performSearch()
    } else {
      setResults([])
      setIsSearching(false)
    }
  }, [deferredTerm, searchFunction])

  return {
    results,
    isSearching,
    isStale: searchTerm !== deferredTerm
  }
}

function UserSearch() {
  const [searchTerm, setSearchTerm] = useState(&#39;&#39;)
  
  const searchUsers = useCallback(async (term) =&gt; {
    const response = await fetch(`/api/users/search?q=${term}`)
    return response.json()
  }, [])

  const { results, isSearching, isStale } = useDeferredSearch(searchTerm, searchUsers)

  return (
    &lt;div&gt;
      &lt;input
        type=&quot;text&quot;
        value={searchTerm}
        onChange={(e) =&gt; setSearchTerm(e.target.value)}
        placeholder=&quot;搜索用户...&quot;
      /&gt;
      
      &lt;div className={isStale ? &#39;stale-results&#39; : &#39;&#39;}&gt;
        {isSearching &amp;&amp; &lt;div&gt;搜索中...&lt;/div&gt;}
        {isStale &amp;&amp; &lt;div&gt;结果更新中...&lt;/div&gt;}
        
        {results.map(user =&gt; (
          &lt;UserCard key={user.id} user={user} /&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<h3>注意事项</h3>
<ol>
<li><strong>值延迟</strong> - 延迟值会在紧急更新期间保持旧值</li>
<li><strong>性能优化</strong> - 与useMemo结合使用效果更佳</li>
<li><strong>用户反馈</strong> - 通过比较原值和延迟值提供视觉反馈</li>
<li><strong>适用场景</strong> - 适合昂贵的计算或渲染操作</li>
</ol>
<hr>
<h2>useSyncExternalStore</h2>
<p>订阅外部数据源的Hook。</p>
<h3>语法</h3>
<pre><code class="language-typescript">const snapshot = useSyncExternalStore&lt;T&gt;(
  subscribe: (onStoreChange: () =&gt; void) =&gt; () =&gt; void,
  getSnapshot: () =&gt; T,
  getServerSnapshot?: () =&gt; T
): T
</code></pre>
<h3>参数</h3>
<ul>
<li><strong>subscribe</strong>: <code>(onStoreChange: () =&gt; void) =&gt; () =&gt; void</code> - 订阅存储变化的函数</li>
<li><strong>getSnapshot</strong>: <code>() =&gt; T</code> - 获取当前快照的函数</li>
<li><strong>getServerSnapshot</strong>: <code>() =&gt; T</code> (可选) - 服务端渲染时获取快照的函数</li>
</ul>
<h3>返回值</h3>
<ul>
<li><strong>snapshot</strong>: <code>T</code> - 存储的当前快照</li>
</ul>
<h3>使用规则</h3>
<ol>
<li>只能在函数组件或自定义Hook中调用</li>
<li>必须在组件的顶层调用</li>
<li>getSnapshot函数必须是纯函数</li>
</ol>
<h3>使用场景</h3>
<ul>
<li>与外部状态管理库集成</li>
<li>订阅浏览器API</li>
<li>监听全局事件</li>
<li>第三方数据源集成</li>
</ul>
<h3>代码示例</h3>
<pre><code class="language-jsx">// 订阅窗口尺寸
function useWindowSize() {
  const size = useSyncExternalStore(
    (callback) =&gt; {
      window.addEventListener(&#39;resize&#39;, callback)
      return () =&gt; window.removeEventListener(&#39;resize&#39;, callback)
    },
    () =&gt; ({ width: window.innerWidth, height: window.innerHeight }),
    () =&gt; ({ width: 1024, height: 768 }) // 服务端默认值
  )

  return size
}

function ResponsiveComponent() {
  const { width, height } = useWindowSize()

  return (
    &lt;div&gt;
      &lt;p&gt;窗口尺寸: {width} × {height}&lt;/p&gt;
      {width &lt; 768 ? &lt;MobileLayout /&gt; : &lt;DesktopLayout /&gt;}
    &lt;/div&gt;
  )
}

// 订阅在线状态
function useOnlineStatus() {
  const isOnline = useSyncExternalStore(
    (callback) =&gt; {
      window.addEventListener(&#39;online&#39;, callback)
      window.addEventListener(&#39;offline&#39;, callback)
      return () =&gt; {
        window.removeEventListener(&#39;online&#39;, callback)
        window.removeEventListener(&#39;offline&#39;, callback)
      }
    },
    () =&gt; navigator.onLine,
    () =&gt; true // 服务端默认为在线
  )

  return isOnline
}

function NetworkStatus() {
  const isOnline = useOnlineStatus()

  return (
    &lt;div className={`status ${isOnline ? &#39;online&#39; : &#39;offline&#39;}`}&gt;
      {isOnline ? &#39;🟢 在线&#39; : &#39;🔴 离线&#39;}
    &lt;/div&gt;
  )
}

// 订阅本地存储
function useLocalStorageValue(key) {
  const value = useSyncExternalStore(
    (callback) =&gt; {
      const handleStorageChange = (e) =&gt; {
        if (e.key === key) {
          callback()
        }
      }
      
      window.addEventListener(&#39;storage&#39;, handleStorageChange)
      return () =&gt; window.removeEventListener(&#39;storage&#39;, handleStorageChange)
    },
    () =&gt; {
      try {
        const item = localStorage.getItem(key)
        return item ? JSON.parse(item) : null
      } catch {
        return null
      }
    },
    () =&gt; null // 服务端无localStorage
  )

  const setValue = useCallback((newValue) =&gt; {
    try {
      localStorage.setItem(key, JSON.stringify(newValue))
      // 手动触发事件，因为同页面修改不会触发storage事件
      window.dispatchEvent(new StorageEvent(&#39;storage&#39;, { key }))
    } catch (error) {
      console.error(&#39;Failed to set localStorage:&#39;, error)
    }
  }, [key])

  return [value, setValue]
}

function Settings() {
  const [theme, setTheme] = useLocalStorageValue(&#39;theme&#39;)
  const [language, setLanguage] = useLocalStorageValue(&#39;language&#39;)

  return (
    &lt;div&gt;
      &lt;div&gt;
        &lt;label&gt;主题: &lt;/label&gt;
        &lt;select 
          value={theme || &#39;light&#39;} 
          onChange={(e) =&gt; setTheme(e.target.value)}
        &gt;
          &lt;option value=&quot;light&quot;&gt;明亮&lt;/option&gt;
          &lt;option value=&quot;dark&quot;&gt;暗黑&lt;/option&gt;
        &lt;/select&gt;
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label&gt;语言: &lt;/label&gt;
        &lt;select 
          value={language || &#39;zh&#39;} 
          onChange={(e) =&gt; setLanguage(e.target.value)}
        &gt;
          &lt;option value=&quot;zh&quot;&gt;中文&lt;/option&gt;
          &lt;option value=&quot;en&quot;&gt;English&lt;/option&gt;
        &lt;/select&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  )
}

// 与外部状态管理库集成（模拟）
class SimpleStore {
  constructor(initialState) {
    this.state = initialState
    this.listeners = []
  }

  subscribe(listener) {
    this.listeners.push(listener)
    return () =&gt; {
      this.listeners = this.listeners.filter(l =&gt; l !== listener)
    }
  }

  getState() {
    return this.state
  }

  setState(newState) {
    this.state = { ...this.state, ...newState }
    this.listeners.forEach(listener =&gt; listener())
  }
}

const globalStore = new SimpleStore({
  user: null,
  theme: &#39;light&#39;,
  notifications: []
})

function useStore(selector) {
  const snapshot = useSyncExternalStore(
    globalStore.subscribe.bind(globalStore),
    () =&gt; selector(globalStore.getState()),
    () =&gt; selector({}) // 服务端初始状态
  )

  return snapshot
}

function UserProfile() {
  const user = useStore(state =&gt; state.user)
  const theme = useStore(state =&gt; state.theme)

  if (!user) {
    return &lt;div&gt;请登录&lt;/div&gt;
  }

  return (
    &lt;div className={`profile theme-${theme}`}&gt;
      &lt;h2&gt;{user.name}&lt;/h2&gt;
      &lt;p&gt;{user.email}&lt;/p&gt;
    &lt;/div&gt;
  )
}

function ThemeToggle() {
  const theme = useStore(state =&gt; state.theme)

  const toggleTheme = () =&gt; {
    globalStore.setState({ 
      theme: theme === &#39;light&#39; ? &#39;dark&#39; : &#39;light&#39; 
    })
  }

  return (
    &lt;button onClick={toggleTheme}&gt;
      切换到 {theme === &#39;light&#39; ? &#39;暗黑&#39; : &#39;明亮&#39;} 主题
    &lt;/button&gt;
  )
}

// 订阅媒体查询
function useMediaQuery(query) {
  const matches = useSyncExternalStore(
    (callback) =&gt; {
      const mediaQuery = window.matchMedia(query)
      mediaQuery.addEventListener(&#39;change&#39;, callback)
      return () =&gt; mediaQuery.removeEventListener(&#39;change&#39;, callback)
    },
    () =&gt; window.matchMedia(query).matches,
    () =&gt; false
  )

  return matches
}

function ResponsiveNavigation() {
  const isMobile = useMediaQuery(&#39;(max-width: 768px)&#39;)
  const isTablet = useMediaQuery(&#39;(min-width: 769px) and (max-width: 1024px)&#39;)

  if (isMobile) {
    return &lt;MobileNavigation /&gt;
  }

  if (isTablet) {
    return &lt;TabletNavigation /&gt;
  }

  return &lt;DesktopNavigation /&gt;
}

// 自定义Hook - 订阅地理位置
function useGeolocation() {
  const position = useSyncExternalStore(
    (callback) =&gt; {
      const watchId = navigator.geolocation.watchPosition(
        callback,
        callback,
        { enableHighAccuracy: true }
      )
      
      return () =&gt; navigator.geolocation.clearWatch(watchId)
    },
    () =&gt; {
      // 同步获取位置比较困难，这里返回null
      return null
    },
    () =&gt; null
  )

  return position
}

function LocationDisplay() {
  const position = useGeolocation()

  if (!position) {
    return &lt;div&gt;获取位置中...&lt;/div&gt;
  }

  return (
    &lt;div&gt;
      &lt;p&gt;纬度: {position.coords.latitude}&lt;/p&gt;
      &lt;p&gt;经度: {position.coords.longitude}&lt;/p&gt;
      &lt;p&gt;精度: {position.coords.accuracy}米&lt;/p&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<h3>注意事项</h3>
<ol>
<li><strong>同步性</strong> - getSnapshot必须是同步函数</li>
<li><strong>一致性</strong> - 相同输入必须返回相同结果</li>
<li><strong>服务端渲染</strong> - 提供getServerSnapshot避免hydration不匹配</li>
<li><strong>性能考虑</strong> - 避免在getSnapshot中进行昂贵计算</li>
</ol>
<hr>
<h2>useInsertionEffect</h2>
<p>在DOM变更之前同步触发的effect，主要用于CSS-in-JS库。</p>
<h3>语法</h3>
<pre><code class="language-typescript">useInsertionEffect(
  effect: () =&gt; void | (() =&gt; void),
  deps?: readonly unknown[]
): void
</code></pre>
<h3>参数</h3>
<ul>
<li><strong>effect</strong>: <code>() =&gt; void | (() =&gt; void)</code> - 副作用函数</li>
<li><strong>deps</strong>: <code>readonly unknown[]</code> (可选) - 依赖数组</li>
</ul>
<h3>返回值</h3>
<p>无返回值</p>
<h3>使用规则</h3>
<ol>
<li>只能在函数组件或自定义Hook中调用</li>
<li>必须在组件的顶层调用</li>
<li>在所有DOM变更之前执行</li>
</ol>
<h3>使用场景</h3>
<ul>
<li>CSS-in-JS样式注入</li>
<li>动态样式表管理</li>
<li>第三方样式库集成</li>
<li>DOM操作前的样式准备</li>
</ul>
<h3>代码示例</h3>
<pre><code class="language-jsx">// CSS-in-JS样式注入
function useCSS(css) {
  const cssId = useId()

  useInsertionEffect(() =&gt; {
    // 在DOM更新前注入样式
    const style = document.createElement(&#39;style&#39;)
    style.id = cssId
    style.textContent = css
    document.head.appendChild(style)

    return () =&gt; {
      // 清理样式
      const existingStyle = document.getElementById(cssId)
      if (existingStyle) {
        document.head.removeChild(existingStyle)
      }
    }
  }, [css, cssId])
}

function StyledButton({ children, color = &#39;blue&#39; }) {
  const css = `
    .button-${color} {
      background-color: ${color};
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
    }
    .button-${color}:hover {
      opacity: 0.8;
    }
  `

  useCSS(css)

  return (
    &lt;button className={`button-${color}`}&gt;
      {children}
    &lt;/button&gt;
  )
}

// 动态主题样式
function useThemeStyles(theme) {
  useInsertionEffect(() =&gt; {
    const themeStyles = {
      light: `
        :root {
          --bg-color: #ffffff;
          --text-color: #000000;
          --border-color: #e0e0e0;
        }
      `,
      dark: `
        :root {
          --bg-color: #1a1a1a;
          --text-color: #ffffff;
          --border-color: #333333;
        }
      `
    }

    const styleId = &#39;theme-styles&#39;
    let style = document.getElementById(styleId)
    
    if (!style) {
      style = document.createElement(&#39;style&#39;)
      style.id = styleId
      document.head.appendChild(style)
    }

    style.textContent = themeStyles[theme] || themeStyles.light

    return () =&gt; {
      // 组件卸载时不清理，因为主题是全局的
    }
  }, [theme])
}

function App() {
  const [theme, setTheme] = useState(&#39;light&#39;)
  
  useThemeStyles(theme)

  return (
    &lt;div className=&quot;app&quot;&gt;
      &lt;button onClick={() =&gt; setTheme(theme === &#39;light&#39; ? &#39;dark&#39; : &#39;light&#39;)}&gt;
        切换主题
      &lt;/button&gt;
      &lt;div&gt;当前主题: {theme}&lt;/div&gt;
    &lt;/div&gt;
  )
}

// 动态字体加载
function useDynamicFont(fontFamily, fontUrl) {
  useInsertionEffect(() =&gt; {
    if (!fontFamily || !fontUrl) return

    const fontId = `font-${fontFamily.replace(/\s+/g, &#39;-&#39;).toLowerCase()}`
    
    // 检查字体是否已加载
    if (document.getElementById(fontId)) return

    const style = document.createElement(&#39;style&#39;)
    style.id = fontId
    style.textContent = `
      @font-face {
        font-family: &#39;${fontFamily}&#39;;
        src: url(&#39;${fontUrl}&#39;) format(&#39;woff2&#39;);
        font-display: swap;
      }
    `
    
    document.head.appendChild(style)

    return () =&gt; {
      const existingStyle = document.getElementById(fontId)
      if (existingStyle) {
        document.head.removeChild(existingStyle)
      }
    }
  }, [fontFamily, fontUrl])
}

function CustomFontText({ fontFamily, fontUrl, children }) {
  useDynamicFont(fontFamily, fontUrl)

  return (
    &lt;div style={{ fontFamily: fontFamily }}&gt;
      {children}
    &lt;/div&gt;
  )
}

// CSS变量动态更新
function useCSSVariables(variables) {
  useInsertionEffect(() =&gt; {
    const root = document.documentElement
    
    // 设置CSS变量
    Object.entries(variables).forEach(([key, value]) =&gt; {
      root.style.setProperty(`--${key}`, value)
    })

    return () =&gt; {
      // 清理CSS变量
      Object.keys(variables).forEach(key =&gt; {
        root.style.removeProperty(`--${key}`)
      })
    }
  }, [variables])
}

function ColorfulComponent() {
  const [primaryColor, setPrimaryColor] = useState(&#39;#007bff&#39;)
  const [secondaryColor, setSecondaryColor] = useState(&#39;#6c757d&#39;)

  useCSSVariables({
    &#39;primary-color&#39;: primaryColor,
    &#39;secondary-color&#39;: secondaryColor
  })

  return (
    &lt;div&gt;
      &lt;div 
        style={{ 
          backgroundColor: &#39;var(--primary-color)&#39;, 
          color: &#39;white&#39;,
          padding: &#39;16px&#39; 
        }}
      &gt;
        主要颜色区域
      &lt;/div&gt;
      
      &lt;div 
        style={{ 
          backgroundColor: &#39;var(--secondary-color)&#39;, 
          color: &#39;white&#39;,
          padding: &#39;16px&#39;,
          marginTop: &#39;8px&#39;
        }}
      &gt;
        次要颜色区域
      &lt;/div&gt;

      &lt;div&gt;
        &lt;input
          type=&quot;color&quot;
          value={primaryColor}
          onChange={(e) =&gt; setPrimaryColor(e.target.value)}
        /&gt;
        &lt;input
          type=&quot;color&quot;
          value={secondaryColor}
          onChange={(e) =&gt; setSecondaryColor(e.target.value)}
        /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  )
}

// 第三方CSS库集成
function useExternalCSS(url) {
  useInsertionEffect(() =&gt; {
    const linkId = `external-css-${url.replace(/[^a-zA-Z0-9]/g, &#39;-&#39;)}`
    
    // 检查是否已经加载
    if (document.getElementById(linkId)) return

    const link = document.createElement(&#39;link&#39;)
    link.id = linkId
    link.rel = &#39;stylesheet&#39;
    link.href = url
    
    document.head.appendChild(link)

    return () =&gt; {
      const existingLink = document.getElementById(linkId)
      if (existingLink) {
        document.head.removeChild(existingLink)
      }
    }
  }, [url])
}

function ComponentWithExternalStyles() {
  useExternalCSS(&#39;https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css&#39;)

  return (
    &lt;div className=&quot;animate__animated animate__bounce&quot;&gt;
      使用外部CSS库的动画组件
    &lt;/div&gt;
  )
}

// 自定义Hook - 样式管理器
function useStyleManager() {
  const stylesRef = useRef(new Map())

  const addStyles = useCallback((id, css) =&gt; {
    useInsertionEffect(() =&gt; {
      if (stylesRef.current.has(id)) return

      const style = document.createElement(&#39;style&#39;)
      style.id = `style-${id}`
      style.textContent = css
      document.head.appendChild(style)
      
      stylesRef.current.set(id, style)

      return () =&gt; {
        const styleElement = stylesRef.current.get(id)
        if (styleElement &amp;&amp; styleElement.parentNode) {
          styleElement.parentNode.removeChild(styleElement)
        }
        stylesRef.current.delete(id)
      }
    }, [id, css])
  }, [])

  const removeStyles = useCallback((id) =&gt; {
    const styleElement = stylesRef.current.get(id)
    if (styleElement &amp;&amp; styleElement.parentNode) {
      styleElement.parentNode.removeChild(styleElement)
    }
    stylesRef.current.delete(id)
  }, [])

  return { addStyles, removeStyles }
}
</code></pre>
<h3>注意事项</h3>
<ol>
<li><strong>执行时机</strong> - 在DOM变更前执行，早于useLayoutEffect</li>
<li><strong>主要用途</strong> - 专为CSS-in-JS库设计</li>
<li><strong>避免滥用</strong> - 不要用于一般的副作用操作</li>
<li><strong>服务端渲染</strong> - 在SSR中不会执行</li>
</ol>
<hr>
<h2>总结</h2>
<p>本文档详细介绍了React所有官方Hooks的使用方法，包括：</p>
<h3>基础Hooks</h3>
<ul>
<li><strong>useState</strong>: 管理组件状态</li>
<li><strong>useEffect</strong>: 处理副作用</li>
<li><strong>useContext</strong>: 消费Context值</li>
</ul>
<h3>额外Hooks</h3>
<ul>
<li><strong>useReducer</strong>: 复杂状态管理</li>
<li><strong>useCallback</strong>: 记忆化回调函数</li>
<li><strong>useMemo</strong>: 记忆化计算值</li>
<li><strong>useRef</strong>: 访问DOM和存储可变值</li>
<li><strong>useImperativeHandle</strong>: 自定义ref接口</li>
<li><strong>useLayoutEffect</strong>: 同步DOM操作</li>
<li><strong>useDebugValue</strong>: 自定义Hook调试</li>
</ul>
<h3>React 18+ Hooks</h3>
<ul>
<li><strong>useId</strong>: 生成唯一ID</li>
<li><strong>useTransition</strong>: 标记过渡更新</li>
<li><strong>useDeferredValue</strong>: 延迟值更新</li>
<li><strong>useSyncExternalStore</strong>: 订阅外部存储</li>
<li><strong>useInsertionEffect</strong>: CSS-in-JS样式注入</li>
</ul>
<h3>使用建议</h3>
<ol>
<li><strong>正确的Hook</strong> - 根据需求选择合适的Hook</li>
<li><strong>依赖数组</strong> - 确保依赖数组的正确性</li>
<li><strong>性能优化</strong> - 适当使用优化类Hook</li>
<li><strong>自定义Hook</strong> - 提取可复用的逻辑</li>
<li><strong>调试工具</strong> - 利用React DevTools调试</li>
</ol>
<p>希望这个完整的参考文档能帮助你更好地掌握React Hooks！ </p>

          </div>

          <!-- 文档导航 -->
          <div class="doc-navigation">
            
              <a href="38-常见问题.html" class="nav-btn prev-btn">
                <span class="nav-icon">←</span>
                <div class="nav-text">
                  <span class="nav-label">上一篇</span>
                  <span class="nav-title">常见问题</span>
                </div>
              </a>
            
            
            <div></div>
          </div>
        </article>
      </main>
    </div>

    <!-- 返回顶部按钮 -->
    <button class="back-to-top" id="backToTop" onclick="scrollToTop()">
      <span>↑</span>
    </button>

    <!-- 底部 -->
    <footer class="footer">
      <div class="footer-content">
        <p>&copy; 2024 React 中文文档. 基于 React 18.x 构建</p>
        <p>Made with ❤️ by React中文社区</p>
      </div>
    </footer>
  </div>

  <script src="assets/script.js"></script>
</body>
</html>