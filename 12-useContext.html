<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>useContext - React 中文文档</title>
  <meta name="description" content="从入门到精通，全面掌握React开发技能">
  <link rel="stylesheet" href="assets/style.css">
  <link rel="stylesheet" href="assets/highlight.css">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>⚛️</text></svg>">
</head>
<body>
  <div class="container">
    <!-- 顶部导航 -->
    <header class="header">
      <div class="header-content">
        <div class="logo">
          <span class="logo-icon">⚛️</span>
          <div class="logo-text">
            <h1>React 中文文档</h1>
            <p>现代化的React学习指南</p>
          </div>
        </div>
        <nav class="header-nav">
          <a href="index.html" class="nav-link">首页</a>
          <a href="#" class="nav-link" onclick="toggleSidebar()">目录</a>
          <a href="https://github.com/facebook/react" target="_blank" class="nav-link">GitHub</a>
        </nav>
      </div>
    </header>

    <div class="main-layout">
      <!-- 侧边栏 -->
      <aside class="sidebar" id="sidebar">
        <div class="sidebar-content">
          <div class="search-box">
            <input type="text" placeholder="搜索文档..." id="searchInput" onkeyup="searchDocs()">
            <span class="search-icon">🔍</span>
          </div>
          <nav class="doc-nav">
            
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">📚</span>
          基础概念
        </h3>
        <ul class="category-docs">
          <li><a href="01-React简介.html" class="doc-link">React简介</a></li><li><a href="02-环境搭建.html" class="doc-link">环境搭建</a></li><li><a href="03-JSX语法.html" class="doc-link">JSX语法</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">🧩</span>
          组件开发
        </h3>
        <ul class="category-docs">
          <li><a href="04-组件基础.html" class="doc-link">组件基础</a></li><li><a href="05-Props与State.html" class="doc-link">Props与State</a></li><li><a href="06-事件处理.html" class="doc-link">事件处理</a></li><li><a href="07-条件渲染.html" class="doc-link">条件渲染</a></li><li><a href="08-列表渲染.html" class="doc-link">列表渲染</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">🎣</span>
          Hooks API
        </h3>
        <ul class="category-docs">
          <li><a href="09-Hooks概述.html" class="doc-link">Hooks概述</a></li><li><a href="10-useState.html" class="doc-link">useState</a></li><li><a href="11-useEffect.html" class="doc-link">useEffect</a></li><li><a href="12-useContext.html" class="doc-link">useContext</a></li><li><a href="13-useReducer.html" class="doc-link">useReducer</a></li><li><a href="14-useMemo和useCallback.html" class="doc-link">useMemo和useCallback</a></li><li><a href="15-useRef.html" class="doc-link">useRef</a></li><li><a href="16-自定义Hooks.html" class="doc-link">自定义Hooks</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">🔄</span>
          生命周期
        </h3>
        <ul class="category-docs">
          <li><a href="17-生命周期方法.html" class="doc-link">生命周期方法</a></li><li><a href="18-副作用处理.html" class="doc-link">副作用处理</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">🎨</span>
          样式与UI
        </h3>
        <ul class="category-docs">
          <li><a href="19-样式处理.html" class="doc-link">样式处理</a></li><li><a href="20-动画效果.html" class="doc-link">动画效果</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">🗺️</span>
          路由管理
        </h3>
        <ul class="category-docs">
          <li><a href="21-React-Router.html" class="doc-link">React-Router</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">📦</span>
          状态管理
        </h3>
        <ul class="category-docs">
          <li><a href="22-Context-API.html" class="doc-link">Context-API</a></li><li><a href="23-Redux集成.html" class="doc-link">Redux集成</a></li><li><a href="24-Zustand状态管理.html" class="doc-link">Zustand状态管理</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">🚀</span>
          性能优化
        </h3>
        <ul class="category-docs">
          <li><a href="25-性能优化技巧.html" class="doc-link">性能优化技巧</a></li><li><a href="26-代码分割.html" class="doc-link">代码分割</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">🧪</span>
          测试
        </h3>
        <ul class="category-docs">
          <li><a href="27-单元测试.html" class="doc-link">单元测试</a></li><li><a href="28-集成测试.html" class="doc-link">集成测试</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">🏗️</span>
          构建与部署
        </h3>
        <ul class="category-docs">
          <li><a href="29-项目构建.html" class="doc-link">项目构建</a></li><li><a href="30-生产部署.html" class="doc-link">生产部署</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">🛠️</span>
          开发工具
        </h3>
        <ul class="category-docs">
          <li><a href="31-开发者工具.html" class="doc-link">开发者工具</a></li><li><a href="32-调试技巧.html" class="doc-link">调试技巧</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">📖</span>
          API参考
        </h3>
        <ul class="category-docs">
          <li><a href="33-React-API完整参考.html" class="doc-link">React-API完整参考</a></li><li><a href="34-DOM元素属性.html" class="doc-link">DOM元素属性</a></li><li><a href="35-合成事件.html" class="doc-link">合成事件</a></li><li><a href="React-Hooks完整参考.html" class="doc-link">React-Hooks完整参考</a></li>
        </ul>
      </div>
      <div class="nav-category">
        <h3 class="category-title">
          <span class="category-icon">💡</span>
          最佳实践
        </h3>
        <ul class="category-docs">
          <li><a href="36-编码规范.html" class="doc-link">编码规范</a></li><li><a href="37-项目架构.html" class="doc-link">项目架构</a></li><li><a href="38-常见问题.html" class="doc-link">常见问题</a></li>
        </ul>
      </div>
          </nav>
        </div>
      </aside>

      <!-- 主内容区 -->
      <main class="content">
        <article class="doc-article">
          <div class="doc-header">
            <div class="breadcrumb">
              <a href="index.html">首页</a>
              <span class="separator">></span>
              <span class="current">useContext</span>
            </div>
            <h1 class="doc-title">useContext</h1>
            <div class="doc-meta">
              <span class="category" style="background: #4facfe">
                🎣 Hooks API
              </span>
            </div>
          </div>
          
          <div class="doc-content">
            <h1>12-useContext</h1>
<p><code>useContext</code> 是React Hooks中用于消费Context的钩子。它提供了一种在组件树中共享状态的方式，避免了通过props逐层传递数据的问题（prop drilling）。</p>
<h2>基础概念</h2>
<h3>什么是Context</h3>
<p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。</p>
<pre><code class="language-jsx">import React, { createContext, useContext } from &#39;react&#39;;

// 创建Context
const ThemeContext = createContext();

// 提供者组件
function App() {
  const theme = {
    primary: &#39;#007bff&#39;,
    secondary: &#39;#6c757d&#39;,
    background: &#39;#ffffff&#39;
  };

  return (
    &lt;ThemeContext.Provider value={theme}&gt;
      &lt;Header /&gt;
      &lt;MainContent /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

// 消费者组件
function Header() {
  const theme = useContext(ThemeContext);
  
  return (
    &lt;header style={{ backgroundColor: theme.primary }}&gt;
      &lt;h1&gt;我的应用&lt;/h1&gt;
    &lt;/header&gt;
  );
}

function MainContent() {
  const theme = useContext(ThemeContext);
  
  return (
    &lt;main style={{ backgroundColor: theme.background }}&gt;
      &lt;p&gt;主要内容&lt;/p&gt;
    &lt;/main&gt;
  );
}
</code></pre>
<h2>创建和使用Context</h2>
<h3>基本步骤</h3>
<ol>
<li><strong>创建Context</strong></li>
<li><strong>提供Context值</strong></li>
<li><strong>消费Context值</strong></li>
</ol>
<pre><code class="language-jsx">// 1. 创建Context
const UserContext = createContext();

// 2. 创建Provider组件
function UserProvider({ children }) {
  const [user, setUser] = useState({
    name: &#39;张三&#39;,
    email: &#39;zhangsan@example.com&#39;,
    role: &#39;admin&#39;
  });

  return (
    &lt;UserContext.Provider value={{ user, setUser }}&gt;
      {children}
    &lt;/UserContext.Provider&gt;
  );
}

// 3. 创建自定义Hook（可选但推荐）
function useUser() {
  const context = useContext(UserContext);
  if (!context) {
    throw new Error(&#39;useUser must be used within a UserProvider&#39;);
  }
  return context;
}

// 4. 在组件中使用
function UserProfile() {
  const { user, setUser } = useUser();

  const handleNameChange = (newName) =&gt; {
    setUser(prev =&gt; ({ ...prev, name: newName }));
  };

  return (
    &lt;div&gt;
      &lt;h2&gt;用户信息&lt;/h2&gt;
      &lt;p&gt;姓名: {user.name}&lt;/p&gt;
      &lt;p&gt;邮箱: {user.email}&lt;/p&gt;
      &lt;p&gt;角色: {user.role}&lt;/p&gt;
      &lt;button onClick={() =&gt; handleNameChange(&#39;李四&#39;)}&gt;
        更改姓名
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

// 5. 使用Provider包装应用
function App() {
  return (
    &lt;UserProvider&gt;
      &lt;UserProfile /&gt;
    &lt;/UserProvider&gt;
  );
}
</code></pre>
<h2>默认值</h2>
<h3>设置Context默认值</h3>
<pre><code class="language-jsx">const ThemeContext = createContext({
  mode: &#39;light&#39;,
  colors: {
    primary: &#39;#007bff&#39;,
    secondary: &#39;#6c757d&#39;
  },
  toggleMode: () =&gt; {}
});

// 即使没有Provider，组件也能获取默认值
function ThemeDisplay() {
  const { mode, colors } = useContext(ThemeContext);
  
  return (
    &lt;div style={{ color: colors.primary }}&gt;
      当前主题: {mode}
    &lt;/div&gt;
  );
}
</code></pre>
<h3>带类型的Context（TypeScript）</h3>
<pre><code class="language-tsx">interface User {
  id: string;
  name: string;
  email: string;
}

interface UserContextType {
  user: User | null;
  setUser: (user: User | null) =&gt; void;
  login: (email: string, password: string) =&gt; Promise&lt;void&gt;;
  logout: () =&gt; void;
}

const UserContext = createContext&lt;UserContextType | undefined&gt;(undefined);

function useUser(): UserContextType {
  const context = useContext(UserContext);
  if (context === undefined) {
    throw new Error(&#39;useUser must be used within a UserProvider&#39;);
  }
  return context;
}

function UserProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState&lt;User | null&gt;(null);

  const login = async (email: string, password: string) =&gt; {
    // 登录逻辑
    const userData = await authAPI.login(email, password);
    setUser(userData);
  };

  const logout = () =&gt; {
    setUser(null);
  };

  const value: UserContextType = {
    user,
    setUser,
    login,
    logout
  };

  return (
    &lt;UserContext.Provider value={value}&gt;
      {children}
    &lt;/UserContext.Provider&gt;
  );
}
</code></pre>
<h2>多个Context</h2>
<h3>组合多个Context</h3>
<pre><code class="language-jsx">const ThemeContext = createContext();
const UserContext = createContext();
const LanguageContext = createContext();

function AppProviders({ children }) {
  return (
    &lt;ThemeProvider&gt;
      &lt;UserProvider&gt;
        &lt;LanguageProvider&gt;
          {children}
        &lt;/LanguageProvider&gt;
      &lt;/UserProvider&gt;
    &lt;/ThemeProvider&gt;
  );
}

// 或者创建组合Provider
function CombinedProvider({ children }) {
  const [theme, setTheme] = useState(&#39;light&#39;);
  const [user, setUser] = useState(null);
  const [language, setLanguage] = useState(&#39;zh&#39;);

  return (
    &lt;ThemeContext.Provider value={{ theme, setTheme }}&gt;
      &lt;UserContext.Provider value={{ user, setUser }}&gt;
        &lt;LanguageContext.Provider value={{ language, setLanguage }}&gt;
          {children}
        &lt;/LanguageContext.Provider&gt;
      &lt;/UserContext.Provider&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

// 使用多个Context
function MyComponent() {
  const { theme } = useContext(ThemeContext);
  const { user } = useContext(UserContext);
  const { language } = useContext(LanguageContext);

  return (
    &lt;div className={`theme-${theme} lang-${language}`}&gt;
      {user ? `Welcome, ${user.name}` : &#39;Please login&#39;}
    &lt;/div&gt;
  );
}
</code></pre>
<h2>实际应用示例</h2>
<h3>主题切换</h3>
<pre><code class="language-jsx">const ThemeContext = createContext();

const themes = {
  light: {
    mode: &#39;light&#39;,
    colors: {
      background: &#39;#ffffff&#39;,
      text: &#39;#000000&#39;,
      primary: &#39;#007bff&#39;
    }
  },
  dark: {
    mode: &#39;dark&#39;,
    colors: {
      background: &#39;#1a1a1a&#39;,
      text: &#39;#ffffff&#39;,
      primary: &#39;#66b3ff&#39;
    }
  }
};

function ThemeProvider({ children }) {
  const [currentTheme, setCurrentTheme] = useState(&#39;light&#39;);

  const toggleTheme = () =&gt; {
    setCurrentTheme(prev =&gt; prev === &#39;light&#39; ? &#39;dark&#39; : &#39;light&#39;);
  };

  const theme = themes[currentTheme];

  return (
    &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;
      &lt;div style={{
        backgroundColor: theme.colors.background,
        color: theme.colors.text,
        minHeight: &#39;100vh&#39;
      }}&gt;
        {children}
      &lt;/div&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error(&#39;useTheme must be used within a ThemeProvider&#39;);
  }
  return context;
}

function ThemeToggleButton() {
  const { theme, toggleTheme } = useTheme();

  return (
    &lt;button
      onClick={toggleTheme}
      style={{
        backgroundColor: theme.colors.primary,
        color: theme.colors.background,
        border: &#39;none&#39;,
        padding: &#39;8px 16px&#39;,
        borderRadius: &#39;4px&#39;
      }}
    &gt;
      切换到{theme.mode === &#39;light&#39; ? &#39;深色&#39; : &#39;浅色&#39;}主题
    &lt;/button&gt;
  );
}
</code></pre>
<h3>购物车Context</h3>
<pre><code class="language-jsx">const CartContext = createContext();

function CartProvider({ children }) {
  const [items, setItems] = useState([]);

  const addItem = (product) =&gt; {
    setItems(prev =&gt; {
      const existingItem = prev.find(item =&gt; item.id === product.id);
      if (existingItem) {
        return prev.map(item =&gt;
          item.id === product.id
            ? { ...item, quantity: item.quantity + 1 }
            : item
        );
      }
      return [...prev, { ...product, quantity: 1 }];
    });
  };

  const removeItem = (productId) =&gt; {
    setItems(prev =&gt; prev.filter(item =&gt; item.id !== productId));
  };

  const updateQuantity = (productId, quantity) =&gt; {
    if (quantity &lt;= 0) {
      removeItem(productId);
      return;
    }
    
    setItems(prev =&gt;
      prev.map(item =&gt;
        item.id === productId ? { ...item, quantity } : item
      )
    );
  };

  const clearCart = () =&gt; {
    setItems([]);
  };

  const getTotalPrice = () =&gt; {
    return items.reduce((total, item) =&gt; total + item.price * item.quantity, 0);
  };

  const getItemCount = () =&gt; {
    return items.reduce((count, item) =&gt; count + item.quantity, 0);
  };

  const value = {
    items,
    addItem,
    removeItem,
    updateQuantity,
    clearCart,
    getTotalPrice,
    getItemCount
  };

  return (
    &lt;CartContext.Provider value={value}&gt;
      {children}
    &lt;/CartContext.Provider&gt;
  );
}

function useCart() {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error(&#39;useCart must be used within a CartProvider&#39;);
  }
  return context;
}

// 购物车组件
function CartSummary() {
  const { items, getTotalPrice, getItemCount } = useCart();

  return (
    &lt;div className=&quot;cart-summary&quot;&gt;
      &lt;h3&gt;购物车&lt;/h3&gt;
      &lt;p&gt;商品数量: {getItemCount()}&lt;/p&gt;
      &lt;p&gt;总价: ¥{getTotalPrice().toFixed(2)}&lt;/p&gt;
      {items.length === 0 &amp;&amp; &lt;p&gt;购物车为空&lt;/p&gt;}
    &lt;/div&gt;
  );
}

function ProductCard({ product }) {
  const { addItem } = useCart();

  return (
    &lt;div className=&quot;product-card&quot;&gt;
      &lt;h4&gt;{product.name}&lt;/h4&gt;
      &lt;p&gt;¥{product.price}&lt;/p&gt;
      &lt;button onClick={() =&gt; addItem(product)}&gt;
        加入购物车
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h3>全局状态管理</h3>
<pre><code class="language-jsx">const AppStateContext = createContext();

function appStateReducer(state, action) {
  switch (action.type) {
    case &#39;SET_LOADING&#39;:
      return { ...state, loading: action.payload };
    case &#39;SET_ERROR&#39;:
      return { ...state, error: action.payload, loading: false };
    case &#39;SET_USER&#39;:
      return { ...state, user: action.payload, loading: false };
    case &#39;SET_NOTIFICATIONS&#39;:
      return { ...state, notifications: action.payload };
    case &#39;ADD_NOTIFICATION&#39;:
      return {
        ...state,
        notifications: [...state.notifications, action.payload]
      };
    case &#39;REMOVE_NOTIFICATION&#39;:
      return {
        ...state,
        notifications: state.notifications.filter(n =&gt; n.id !== action.payload)
      };
    default:
      return state;
  }
}

function AppStateProvider({ children }) {
  const [state, dispatch] = useReducer(appStateReducer, {
    user: null,
    loading: false,
    error: null,
    notifications: []
  });

  const setLoading = (loading) =&gt; {
    dispatch({ type: &#39;SET_LOADING&#39;, payload: loading });
  };

  const setError = (error) =&gt; {
    dispatch({ type: &#39;SET_ERROR&#39;, payload: error });
  };

  const setUser = (user) =&gt; {
    dispatch({ type: &#39;SET_USER&#39;, payload: user });
  };

  const addNotification = (notification) =&gt; {
    const id = Date.now();
    dispatch({
      type: &#39;ADD_NOTIFICATION&#39;,
      payload: { ...notification, id }
    });

    // 自动移除通知
    setTimeout(() =&gt; {
      removeNotification(id);
    }, 5000);
  };

  const removeNotification = (id) =&gt; {
    dispatch({ type: &#39;REMOVE_NOTIFICATION&#39;, payload: id });
  };

  const value = {
    ...state,
    setLoading,
    setError,
    setUser,
    addNotification,
    removeNotification
  };

  return (
    &lt;AppStateContext.Provider value={value}&gt;
      {children}
    &lt;/AppStateContext.Provider&gt;
  );
}

function useAppState() {
  const context = useContext(AppStateContext);
  if (!context) {
    throw new Error(&#39;useAppState must be used within AppStateProvider&#39;);
  }
  return context;
}
</code></pre>
<h2>性能优化</h2>
<h3>避免不必要的重新渲染</h3>
<pre><code class="language-jsx">// ❌ 每次渲染都创建新对象
function BadProvider({ children }) {
  const [user, setUser] = useState(null);

  return (
    &lt;UserContext.Provider value={{ user, setUser }}&gt;
      {children}
    &lt;/UserContext.Provider&gt;
  );
}

// ✅ 使用useMemo缓存Context值
function GoodProvider({ children }) {
  const [user, setUser] = useState(null);

  const value = useMemo(() =&gt; ({
    user,
    setUser
  }), [user]);

  return (
    &lt;UserContext.Provider value={value}&gt;
      {children}
    &lt;/UserContext.Provider&gt;
  );
}
</code></pre>
<h3>分离频繁变化的状态</h3>
<pre><code class="language-jsx">// 分离快速变化的状态和稳定的状态
const UserContext = createContext();
const UserActionsContext = createContext();

function UserProvider({ children }) {
  const [user, setUser] = useState(null);

  // 用户数据（不常变化）
  const userValue = useMemo(() =&gt; user, [user]);

  // 用户操作（稳定的函数）
  const actionsValue = useMemo(() =&gt; ({
    setUser,
    updateProfile: (profile) =&gt; {
      setUser(prev =&gt; ({ ...prev, ...profile }));
    },
    logout: () =&gt; setUser(null)
  }), []);

  return (
    &lt;UserContext.Provider value={userValue}&gt;
      &lt;UserActionsContext.Provider value={actionsValue}&gt;
        {children}
      &lt;/UserActionsContext.Provider&gt;
    &lt;/UserContext.Provider&gt;
  );
}

function useUser() {
  const user = useContext(UserContext);
  if (user === undefined) {
    throw new Error(&#39;useUser must be used within UserProvider&#39;);
  }
  return user;
}

function useUserActions() {
  const actions = useContext(UserActionsContext);
  if (!actions) {
    throw new Error(&#39;useUserActions must be used within UserProvider&#39;);
  }
  return actions;
}
</code></pre>
<h3>条件渲染Provider</h3>
<pre><code class="language-jsx">function ConditionalProvider({ children, condition }) {
  if (condition) {
    return (
      &lt;SomeContext.Provider value={someValue}&gt;
        {children}
      &lt;/SomeContext.Provider&gt;
    );
  }
  
  return children;
}
</code></pre>
<h2>最佳实践</h2>
<h3>1. 创建自定义Hook</h3>
<pre><code class="language-jsx">// 为每个Context创建自定义Hook
function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error(&#39;useAuth must be used within an AuthProvider&#39;);
  }
  return context;
}
</code></pre>
<h3>2. 提供有意义的默认值</h3>
<pre><code class="language-jsx">const ThemeContext = createContext({
  mode: &#39;light&#39;,
  toggleMode: () =&gt; {
    console.warn(&#39;ThemeContext used outside of provider&#39;);
  }
});
</code></pre>
<h3>3. 错误边界处理</h3>
<pre><code class="language-jsx">function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [error, setError] = useState(null);

  if (error) {
    throw error; // 让Error Boundary捕获
  }

  const login = async (credentials) =&gt; {
    try {
      const user = await authService.login(credentials);
      setUser(user);
    } catch (err) {
      setError(err);
    }
  };

  return (
    &lt;AuthContext.Provider value={{ user, login }}&gt;
      {children}
    &lt;/AuthContext.Provider&gt;
  );
}
</code></pre>
<h3>4. 组合Context Providers</h3>
<pre><code class="language-jsx">function Providers({ children }) {
  return (
    &lt;ErrorBoundary&gt;
      &lt;AuthProvider&gt;
        &lt;ThemeProvider&gt;
          &lt;NotificationProvider&gt;
            {children}
          &lt;/NotificationProvider&gt;
        &lt;/ThemeProvider&gt;
      &lt;/AuthProvider&gt;
    &lt;/ErrorBoundary&gt;
  );
}
</code></pre>
<h2>常见问题</h2>
<h3>问题1：Context值为undefined</h3>
<pre><code class="language-jsx">// ❌ 没有检查Context是否存在
function BadComponent() {
  const { user } = useContext(UserContext); // 可能为undefined
  return &lt;div&gt;{user.name}&lt;/div&gt;; // 错误！
}

// ✅ 正确的错误处理
function GoodComponent() {
  const context = useContext(UserContext);
  if (!context) {
    throw new Error(&#39;Component must be used within UserProvider&#39;);
  }
  const { user } = context;
  return &lt;div&gt;{user?.name || &#39;Guest&#39;}&lt;/div&gt;;
}
</code></pre>
<h3>问题2：过度使用Context</h3>
<pre><code class="language-jsx">// ❌ 为每个小状态创建Context
const CountContext = createContext();
const NameContext = createContext();
const EmailContext = createContext();

// ✅ 合并相关状态
const UserFormContext = createContext();

function UserFormProvider({ children }) {
  const [formData, setFormData] = useState({
    count: 0,
    name: &#39;&#39;,
    email: &#39;&#39;
  });

  return (
    &lt;UserFormContext.Provider value={{ formData, setFormData }}&gt;
      {children}
    &lt;/UserFormContext.Provider&gt;
  );
}
</code></pre>
<h3>问题3：Context导致的性能问题</h3>
<pre><code class="language-jsx">// ❌ 频繁变化的值导致所有消费者重新渲染
function BadProvider({ children }) {
  const [counter, setCounter] = useState(0);
  const [user, setUser] = useState(null);

  useEffect(() =&gt; {
    const timer = setInterval(() =&gt; setCounter(c =&gt; c + 1), 1000);
    return () =&gt; clearInterval(timer);
  }, []);

  return (
    &lt;MyContext.Provider value={{ counter, user, setUser }}&gt;
      {children}
    &lt;/MyContext.Provider&gt;
  );
}

// ✅ 分离频繁变化的状态
function GoodProvider({ children }) {
  const [user, setUser] = useState(null);

  const userActions = useMemo(() =&gt; ({
    setUser,
    updateUser: (updates) =&gt; setUser(prev =&gt; ({ ...prev, ...updates }))
  }), []);

  return (
    &lt;UserContext.Provider value={user}&gt;
      &lt;UserActionsContext.Provider value={userActions}&gt;
        &lt;CounterProvider&gt;
          {children}
        &lt;/CounterProvider&gt;
      &lt;/UserActionsContext.Provider&gt;
    &lt;/UserContext.Provider&gt;
  );
}
</code></pre>
<h2>总结</h2>
<p><code>useContext</code> 是React中强大的状态共享工具：</p>
<ol>
<li><strong>避免prop drilling</strong>：直接在组件树中传递数据</li>
<li><strong>创建自定义Hook</strong>：提供更好的开发体验</li>
<li><strong>性能优化</strong>：使用useMemo避免不必要的重新渲染</li>
<li><strong>最佳实践</strong>：合理组织Context，避免过度使用</li>
</ol>
<p>正确使用Context可以让你的React应用状态管理更加简洁和高效。 </p>

          </div>

          <!-- 文档导航 -->
          <div class="doc-navigation">
            
              <a href="11-useEffect.html" class="nav-btn prev-btn">
                <span class="nav-icon">←</span>
                <div class="nav-text">
                  <span class="nav-label">上一篇</span>
                  <span class="nav-title">useEffect</span>
                </div>
              </a>
            
            
            
              <a href="13-useReducer.html" class="nav-btn next-btn">
                <div class="nav-text">
                  <span class="nav-label">下一篇</span>
                  <span class="nav-title">useReducer</span>
                </div>
                <span class="nav-icon">→</span>
              </a>
            
          </div>
        </article>
      </main>
    </div>

    <!-- 返回顶部按钮 -->
    <button class="back-to-top" id="backToTop" onclick="scrollToTop()">
      <span>↑</span>
    </button>

    <!-- 底部 -->
    <footer class="footer">
      <div class="footer-content">
        <p>&copy; 2024 React 中文文档. 基于 React 18.x 构建</p>
        <p>Made with ❤️ by React中文社区</p>
      </div>
    </footer>
  </div>

  <script src="assets/script.js"></script>
</body>
</html>